# v1.4 共享状态与任务锁

**Date:** 2026-02-02
**Version:** v1.4
**Focus:** 共享状态文件 + 任务锁机制

---

## 现状

### 已完成（v1.0 - v1.3）

| 组件 | 状态 | 说明 |
|------|------|------|
| `swarm/status_broadcaster.py` | ✅ | 状态广播功能存在（尚未脚本化） |
| `swarm/task_lock.py` | ✅ | 任务锁功能存在（尚未脚本化） |
| `/tmp/ai_swarm/` 目录结构 | ✅ | 约定目录：status.log, locks/ |
| `claude_comm.sh` | ✅ | v1.3 脚本套件可用 |

### 当前问题

- status.log 和 locks/ 操作需通过 Python 模块，外部脚本无法直接使用
- 外部 Claude CLI Worker 无法直接读写状态或获取锁
- 缺少独立的状态协议文档

---

## 设计

### 目标 1: 共享状态文件 (status.log)

**功能：** 记录 Worker 状态变更，供 Master 和其他 Agent 感知

**目录结构（v1.4 范围）：**
```
/tmp/ai_swarm/
├── status.log          # 状态变更记录
└── locks/              # 任务锁目录
    ├── task_001.lock
    ├── task_002.lock
    └── ...
```

**status.log 格式（JSON Lines）：**
```json
{"timestamp": "2026-02-02T10:30:00Z", "type": "START", "worker": "worker-0", "task_id": "task-001"}
{"timestamp": "2026-02-02T10:30:05Z", "type": "DONE", "worker": "worker-0", "task_id": "task-001"}
{"timestamp": "2026-02-02T10:30:10Z", "type": "WAIT", "worker": "worker-1", "task_id": "task-002", "reason": "需要人工确认"}
```

**状态类型：**
- `START` - 任务开始
- `DONE` - 任务完成
- `ERROR` - 任务错误
- `WAIT` - 等待状态
- `HELP` - 需要帮助
- `SKIP` - 跳过任务

### 目标 2: 任务锁机制 (locks/)

**功能：** 防止同一任务被多个 Worker 并发执行

**锁文件格式（JSON）：**
```
# /tmp/ai_swarm/locks/task_001.lock
{
  "task_id": "task-001",
  "worker": "worker-0",
  "acquired_at": "2026-02-02T10:30:00Z",
  "expires_at": "2026-02-02T11:30:00Z"
}
```

**锁操作：**
- `acquire <task_id> <worker> [ttl_seconds]` - 尝试获取锁（原子操作，可选 TTL）
- `release <task_id> <worker>` - 验证身份后释放锁
- `check <task_id>` - 检查锁是否存在
- `list` - 列出所有活跃锁

---

## 实施步骤

### Phase 12: 状态记录脚本

1. 创建 `swarm_status_log.sh`
   - `append <type> <worker> <task_id> [reason]` - 追加状态记录
   - `tail <n>` - 查看最近 N 条记录
   - `query <task_id>` - 查询任务状态变更

2. 脚本支持 `SWARM_STATE_DIR` 环境变量（默认 `/tmp/ai_swarm`）

3. 验证：status.log 正确追加格式，查询返回结果

### Phase 13: 任务锁脚本

1. 创建 `swarm_lock.sh`
   - `acquire <task_id> <worker> [ttl_seconds]` - 原子获取锁，可选 TTL
   - `release <task_id> <worker>` - 验证身份后释放锁
   - `check <task_id>` - 检查锁状态
   - `list` - 列出所有锁

2. 脚本支持 `SWARM_STATE_DIR` 环境变量（默认 `/tmp/ai_swarm`）

3. 验证：acquire 成功后重复 acquire 失败，release 后可重新 acquire

### Phase 14: 集成验证

1. 端到端测试脚本
   - Worker A acquire 锁
   - Worker A append START 到 status.log
   - Worker A 完成，append DONE
   - Worker A release 锁
   - Worker B acquire 同一任务（应成功）
   - 验证 status.log 记录完整

2. 文档：创建 docs/STATUS_PROTO.md

---

## 验收标准

### 必须满足（Must Have）

| # | 标准 | 验证方式 |
|---|------|----------|
| 1 | `swarm_status_log.sh append START worker-0 task-001` 追加有效 JSON 到 status.log | 手动验证 |
| 2 | `swarm_status_log.sh tail 10` 返回最近 10 条状态记录 | 手动验证 |
| 3 | `swarm_status_log.sh query task-001` 返回任务状态变更 | 手动验证 |
| 4 | `swarm_lock.sh acquire task-001 worker-0` 返回锁内容 | 手动验证 |
| 5 | 锁存在时重复 acquire 返回失败 | 手动验证 |
| 6 | `swarm_lock.sh release task-001 worker-0` 成功删除锁 | 手动验证 |
| 7 | release 后可重新 acquire 同一任务 | 手动验证 |
| 8 | `SWARM_STATE_DIR=/custom/path scripts/...` 可在不同目录运行 | 手动验证 |
| 9 | `git diff --name-only swarm/` 无新增修改 | 脚本验证 |

### 可选增强（Nice to Have）

| # | 功能 | 说明 |
|---|------|------|
| N1 | TTL 自动过期 | 锁在 TTL 秒后自动失效，防止死锁 |
| N2 | 批量操作 | `release-all [worker]` 释放该 Worker 所有锁 |
| N3 | 格式校验 | JSON Schema 验证 |

---

## 约束

- **仅脚本实现**：`swarm/*.py` 不修改（若必须修改，说明理由）
- **原子性**：锁 acquire 使用 `O_CREAT|O_EXCL` 保证原子
- **兼容性**：与文档约定目录结构一致（`$SWARM_STATE_DIR/status.log`, `$SWARM_STATE_DIR/locks/`）
- **环境变量**：`SWARM_STATE_DIR` 控制根目录（默认 `/tmp/ai_swarm`）
- **权限**：`/tmp/ai_swarm/` 所有者和权限与现有一致

---

## 输出物

| 文件 | 说明 |
|------|------|
| `scripts/swarm_status_log.sh` | 状态记录脚本 |
| `scripts/swarm_lock.sh` | 任务锁脚本 |
| `docs/STATUS_PROTO.md` | 状态协议文档 |
| `docs/plans/2026-02-02-v1.4-status-locks.md` | 本计划文档 |

---

*Created: 2026-02-02*
*Updated: 2026-02-02 (修正版)*
*Version: v1.4*
