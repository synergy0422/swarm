# v1.3 Claude Code 4 窗口通信协议

**Date:** 2026-02-01
**Version:** v1.3
**Status:** Planning

---

## 一、发现现状

### 1.1 已完成的功能

| 功能 | 状态 | 说明 |
|------|------|------|
| tmux 4 窗口启动 | ✅ | master, worker-0, worker-1, worker-2 |
| Claude CLI 集成 | ✅ | 每个窗口运行 claude CLI |
| Master 扫描 | ✅ | MasterScanner 定期扫描 worker 输出 |
| 状态广播 | ✅ | JSON Lines 格式 (START/DONE/WAIT/ERROR/HELP/SKIP) |
| 自动救援 | ✅ | 检测 [y/n]、Error/Failed 并确认 |

### 1.2 当前架构

```
┌─────────────────────────────────────────────────────┐
│  run_claude_swarm.sh                                │
│  ├── tmux session: swarm-claude-default             │
│  ├── master window → runs: claude                   │
│  ├── worker-0 window → runs: claude                 │
│  ├── worker-1 window → runs: claude                 │
│  └── worker-2 window → runs: claude                 │
└─────────────────────────────────────────────────────┘
```

### 1.3 待解决的问题

1. **任务分发**：Master 如何向 Claude CLI 窗口发送任务描述？
2. **状态回报**：Worker（Claude CLI）如何向 Master 报告任务状态？
3. **消息格式**：如何在 tmux pane 中区分命令和 Claude 输出？
4. **确认机制**：如何确保任务被正确接收？

---

## 二、计划

### 2.1 设计决策

| 维度 | 决策 | 理由 |
|------|------|------|
| 通信模式 | Dispatch (Master→One) | Master 控制任务分配，符合现有架构 |
| 协调方式 | Master decides | 显式分配，便于追踪和去重 |
| 消息格式 | Minimal 标记词 | 简单、视觉清晰、易于解析 |
| 标记词 | [TASK], [DONE], [ERROR], [WAIT], [ACK] | 5 个核心状态词 |
| 交互方式 | Marker lines | 使用标记行区分命令与 Claude 输出 |

### 2.2 约束条件

- ✅ 保持 4 个 Claude Code CLI 窗口（master + worker-0/1/2）
- ✅ 通信仅使用 tmux send-keys / capture-pane
- ✅ 不引入 Web、Pipeline、P2P、后台 Python 任务队列
- ✅ 不改 v1.2 启动脚本核心行为（可新增辅助脚本/约定）
- ✅ 最小化依赖（仅 Python 标准库 + libtmux）

---

## 三、通信协议

### 3.1 核心标记词

| 标记 | 方向 | 含义 |
|------|------|------|
| `[TASK]` | Master→Worker | 任务开始标记 |
| `[ACK]` | Worker→Master | 任务已接收确认 |
| `[DONE]` | Worker→Master | 任务完成 |
| `[ERROR]` | Worker→Master | 任务执行出错 |
| `[WAIT]` | Worker→Master | 等待用户输入/确认 |
| `[HELP]` | Worker→Master | 需要人工干预 |

### 3.2 消息格式

#### 任务消息（Master → Worker）

```
[TASK] {task_id} {target_window}
{任务描述内容}
```

**示例：**
```
[TASK] task-001 worker-0
请帮我创建一个 Python 文件 hello.py，内容为:
print("Hello, AI Swarm!")
```

#### 确认消息（Worker → Master）

```
[ACK] {task_id}
```

**示例：**
```
[ACK] task-001
```

#### 状态消息（Worker → Master）

```
[DONE] {task_id}
# 或
[ERROR] {task_id} 错误描述
# 或
[WAIT] {task_id} 等待原因
```

**示例：**
```
[DONE] task-001
```

### 3.3 消息流程

```
Master                              Worker-0
   │                                   │
   │  [TASK] task-001 worker-0         │
   │  任务描述...                       │
   ├──────────────────────────────────>│
   │                                   │ Claude 解析任务
   │                                   │ 生成 [ACK] task-001
   │  [ACK] task-001                   │
   │<──────────────────────────────────┤
   │   Master 记录任务已确认            │
   │                                   │ Claude 执行任务
   │                                   │ 完成后生成 [DONE]
   │  [DONE] task-001                  │
   │<──────────────────────────────────┤
   │   Master 记录任务完成              │
```

---

## 四、实施步骤

### Phase 11: 通信协议实现

#### Step 1: TmuxSwarmManager 扩展

**文件:** `swarm/tmux_manager.py`

新增方法：
```python
def send_command(self, window_name: str, command: str) -> bool:
    """发送命令到指定窗口（带标记行）"""
    pass

def capture_output(self, window_name: str, since_marker: bool = True) -> List[str]:
    """捕获窗口输出，可选择从标记行开始"""
    pass

def find_marker_positions(self, window_name: str) -> List[int]:
    """查找所有标记行的位置"""
    pass
```

#### Step 2: 状态解析器

**文件:** `swarm/communication.py` (新建)

```python
class StatusParser:
    """解析 Worker 返回的状态标记词"""

    PATTERNS = {
        'ACK': r'\[ACK\]\s*(.+)',
        'DONE': r'\[DONE\]\s*(.+)',
        'ERROR': r'\[ERROR\]\s*(.+)',
        'WAIT': r'\[WAIT\]\s*(.+)',
        'HELP': r'\[HELP\]\s*(.+)',
    }

    @classmethod
    def parse(cls, output: List[str]) -> List[ParsedStatus]:
        """从输出中解析状态标记"""
        pass
```

#### Step 3: Master 通信控制器

**文件:** `swarm/master_comm.py` (新建)

```python
class MasterCommunicator:
    """Master 与 Worker 间的通信控制器"""

    def __init__(self, tmux_manager: TmuxSwarmManager):
        pass

    def dispatch_task(self, task_id: str, worker: str, description: str) -> bool:
        """向指定 Worker 发送任务"""
        pass

    def wait_for_ack(self, task_id: str, timeout: float = 10.0) -> bool:
        """等待 Worker ACK 确认"""
        pass

    def poll_status(self, task_id: str, timeout: float = 60.0) -> Status:
        """轮询 Worker 获取任务状态"""
        pass

    def broadcast_task(self, description: str) -> Dict[str, str]:
        """广播任务到所有 Worker，返回各 Worker 的 ACK"""
        pass
```

#### Step 4: 集成到 Master

修改 `swarm/master.py` 或 `swarm/master_dispatcher.py`：

```python
class Master:
    def __init__(self, ...):
        self.comm = MasterCommunicator(self.tmux)

    def run(self):
        while True:
            task = self.get_next_task()
            if task:
                self.comm.dispatch_task(task.id, task.worker, task.description)
                status = self.comm.poll_status(task.id)
                self.handle_status(status)
            sleep(self.poll_interval)
```

#### Step 5: 测试

**文件:** `tests/test_communication_protocol.py`

```python
def test_send_command():
    """测试 send_command 方法"""

def test_status_parser():
    """测试状态标记词解析"""

def test_ack_timeout():
    """测试 ACK 超时处理"""

def test_dispatch_flow():
    """测试完整分发流程"""
```

---

## 五、验收标准

### 5.1 功能验收

| # | 标准 | 验证方式 |
|---|------|----------|
| 1 | Master 可向 worker-0 发送任务 | 手动测试：send_command() → 检查 pane |
| 2 | Worker 返回 `[ACK]` 确认 | 手动测试：capture_output() 解析 |
| 3 | Worker 返回 `[DONE]` 完成 | 手动测试：Claude 执行后检查 |
| 4 | Worker 返回 `[ERROR]` 错误 | 手动测试：发送错误指令验证 |
| 5 | Master 轮询获取状态 | 手动测试：poll_status() 返回正确状态 |
| 6 | 15 分钟超时处理 | 手动测试：长任务不阻塞 |

### 5.2 集成验收

| # | 标准 | 验证方式 |
|---|------|----------|
| 1 | 与 run_claude_swarm.sh 兼容 | 运行脚本，检查 4 窗口通信 |
| 2 | 不影响现有 MasterScanner | 运行现有测试 |
| 3 | 状态图标正确显示 | swarm status --panes |

### 5.3 自动化测试

```bash
# 运行通信协议测试
pytest tests/test_communication_protocol.py -v

# 运行完整测试套件
pytest tests/ -v --tb=short
```

**通过标准：**
- 所有通信协议测试通过
- 现有测试不回归
- 集成测试通过

---

## 六、文件变更

### 新增文件

| 文件 | 描述 |
|------|------|
| `swarm/communication.py` | 状态解析器 |
| `swarm/master_comm.py` | Master 通信控制器 |
| `tests/test_communication_protocol.py` | 通信协议测试 |
| `docs/plans/2026-02-01-v1.3-claudecode-comm.md` | 本计划文档 |

### 修改文件

| 文件 | 修改内容 |
|------|----------|
| `swarm/tmux_manager.py` | 新增 send_command(), capture_output() |
| `swarm/master.py` | 集成 MasterCommunicator |

---

## 七、风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| Claude CLI 改变输出格式 | 状态解析失败 | 标记词匹配容错，正则宽松匹配 |
| tmux 性能瓶颈 | 轮询延迟 | 可配置轮询间隔，状态变化时通知 |
| 窗口不存在 | 发送失败 | 窗口名验证，错误时快速失败 |
| 编码问题 | 中文乱码 | UTF-8 编码假设 |

---

## 八、时间线

| 阶段 | 预计时间 |
|------|----------|
| Step 1: TmuxSwarmManager 扩展 | 30 分钟 |
| Step 2: 状态解析器 | 20 分钟 |
| Step 3: Master 通信控制器 | 30 分钟 |
| Step 4: 集成到 Master | 20 分钟 |
| Step 5: 测试 | 30 分钟 |
| **总计** | **~2.5 小时** |

---

*Plan created: 2026-02-01*
