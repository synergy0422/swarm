# v1.93 Root Cause Report: Master-Worker Dispatch Closure

**Date:** 2026-02-06
**Phase:** Phase 1 - Root Cause Debug (Evidence Gathering)
**Author:** GSD Execution Agent

---

## 1. What Was Tested

### 1.1 Code Analysis (Static)

| Component | Method | Result |
|-----------|--------|--------|
| `claude_bridge.py` | Code review | Identified 5 potential issues |
| `swarm_bridge.sh` | Script review | Verified bridge launch flow |
| `swarm_layout_5.sh` | Script review | Verified tmux layout creation |
| `tests/test_claude_bridge.py` | Test coverage review | 517 lines, good coverage |

### 1.2 Debug Script Created

**File:** `/home/user/projects/AAA/swarm/scripts/swarm_bridge_debug.sh`

This script performs the following tests:

| Test | Description | Expected Output |
|------|-------------|-----------------|
| Send-Keys Reachability | Injects unique marker `DEBUG_REACH_<ts>_TEST` to each worker pane | Worker 0: FOUND/NOT FOUND, Worker 1: FOUND/NOT FOUND, Worker 2: FOUND/NOT FOUND |
| Worker ACK Response | Sends `TASK: ACK_TEST_PLEASE_REPLY [bridge-task-id:<id>]` to each worker | Response found, ECHO_ONLY, or NO response |
| Full Dispatch Chain | Injects task via master pane, captures all panes for 60s | Task captured by Bridge, dispatched to worker, worker response |

### 1.3 Evidence Files Generated by Debug Script

```
/tmp/ai_swarm_debug_<timestamp>/
├── master_pane_id.txt           # Master pane ID
├── worker_panes.txt             # List of worker pane IDs
├── bridge_stdout.log            # Bridge stdout/stderr
├── bridge.pid                   # Bridge process ID
├── send_keys_reachability.log   # Send-keys test results
├── worker_ack_test.log          # ACK test results
├── full_dispatch_test.log       # Full dispatch analysis
├── master_dispatch_capture.log  # Master pane continuous capture
├── worker_X_dispatch_capture.log # Worker pane captures
└── worker_X_ack_capture.log     # Worker ACK test captures
```

---

## 2. What Worked (Based on Code Analysis)

### 2.1 FIFO Dispatch Path (Working)

```python
# claude_bridge.py:494-516
def _write_to_fifo(self, task: str) -> bool:
    success = write_to_fifo_nonblocking(self.fifo_path, task)

    if success:
        # Send dispatch confirmation via send-keys
        dispatch_msg = f"[DISPATCHED] {task[:60]}"
        self._send_keys(dispatch_msg)
        self._log_status("dispatched", task=task[:100], method="fifo+send-keys")
```

**Evidence:**
- FIFO write has confirmation path
- Dispatch status logged to `bridge.log`
- Master pane shows `[DISPATCHED]` confirmation

### 2.2 Task Parser (Working)

```python
# claude_bridge.py:196-250
class TaskParser:
    PATTERN_TASK = re.compile(r'^\s*/task\s+(.+)$')
    PATTERN_TASK_COLON = re.compile(r'^\s*TASK:\s*(.+)$')

    def parse(self, line: str) -> Optional[str]:
        # Normalizes prompt prefixes: "❯ TASK: ..." -> "TASK: ..."
        normalized = re.sub(r'^\s*[❯>$#]+\s*', '', line)
```

**Evidence:**
- Supports `/task <prompt>` and `TASK: <prompt>` formats
- Handles common terminal prefixes
- LineFilter prevents duplicate processing

### 2.3 Deduplication (Working)

```python
# claude_bridge.py:111-193
class DedupeState:
    def is_duplicate(self, task_content: str) -> Tuple[bool, str]:
        task_hash = hashlib.md5(task_content.encode()).hexdigest()[:16]
        # Sliding window cache with persistence
```

**Evidence:**
- MD5 hash-based deduplication
- Sliding window prevents reprocessing
- State persists across restarts

---

## 3. What Failed (Evidence from Code Analysis)

### 3.1 Issue: Direct Dispatch Has No ACK Verification

**Location:** `claude_bridge.py:474-492`

```python
def _dispatch_to_worker(self, task: str):
    """Direct-dispatch task to worker panes in round-robin mode."""
    panes = self._get_worker_panes()
    if not panes:
        return None

    pane_id = panes[self._dispatch_index % len(panes)]
    self._dispatch_index += 1

    # Use TASK prefix to keep worker context explicit.
    payload = f"TASK: {task}"
    if self._send_text_to_pane(pane_id, payload):
        return pane_id  # <-- Returns on tmux success, NOT worker ACK
    return None
```

**Problem:**
- `tmux send-keys` success does NOT mean Claude received/processed the task
- No verification that worker pane actually contains the dispatched text
- No timeout or retry mechanism

**Evidence:**
- Method returns immediately after `tmux send-keys`
- `_send_text_to_pane` returns True on subprocess success
- No subsequent capture-pane to verify delivery

### 3.2 Issue: No Worker Health Check

**Location:** `claude_bridge.py:481-492`

```python
pane_id = panes[self._dispatch_index % len(panes)]  # Round-robin only
self._dispatch_index += 1
```

**Problem:**
- Simple modulo-based round-robin
- No mechanism to detect unresponsive workers
- Failed dispatches are silently dropped

**Evidence:**
- No heartbeat or ping mechanism
- `_get_worker_panes` returns pane IDs but no status
- Failed dispatch returns None without logging

### 3.3 Issue: Bridge Output Filtering May Hide Clues

**Location:** `claude_bridge.py:44-108`

```python
class LineFilter:
    BRIDGE_PATTERNS = [
        r'\[Bridge\]',
        r'\[FIFO\]',
        r'\[DISPATCHED\]',
        r'-> FIFO:',
    ]

    CLAUDE_ECHO_PATTERNS = [
        r'^Sure,?\s*I will',
        r"^I'll\s+",
        r"^Here's",
        r'^\[.*\]',  # <-- May filter Claude markers like [THINKING]
        r'^{.*}$',   # <-- May filter JSON output
    ]
```

**Problem:**
- `[THINKING]` and JSON markers are filtered during capture
- These patterns might be needed to understand worker state
- Overly aggressive filtering

**Evidence:**
- `LineFilter.should_ignore()` used in `_process_capture`
- LineFilter patterns applied to ALL captured output

### 3.4 Issue: No Dispatch Confirmation to Master

**Location:** `claude_bridge.py:519-543`

```python
# Optional fallback: direct-dispatch to worker Claude panes
if self.direct_fallback:
    pane_id = self._dispatch_to_worker(task)
    if pane_id:
        dispatch_msg = f"[DISPATCHED->WORKER {pane_id}] {task[:60]}"
        self._send_keys(dispatch_msg)  # <-- Visual confirmation only
```

**Problem:**
- `[DISPATCHED->WORKER X]` is just visual feedback
- No verification that worker X actually received the task
- User cannot distinguish between "sent to tmux" and "processed by Claude"

**Evidence:**
- `dispatch_msg` is sent to master pane via `send_keys`
- This is confirmation of dispatch attempt, not completion

### 3.5 Issue: No Structured Phase Logging for Direct Dispatch

**Location:** `claude_bridge.py:546-582`

```python
def _log_status(self, status: str, **extra):
    # bridge.log: Plain text "[timestamp] status"
    # status.log: JSONL with meta.type=BRIDGE
```

**Problem:**
- No phases like `DISPATCHED`, `ACKED`, `RETRY`, `FAILED`
- Cannot trace task lifecycle through logs
- Debugging requires manual log correlation

**Evidence:**
- `_log_status` called with simple strings: "dispatched", "dispatched_direct"
- No `bridge_task_id` tracking for direct dispatch
- No attempt counting or latency measurement

---

## 4. Primary Root Cause

### **Root Cause: Missing Dispatch Verification Loop**

The direct dispatch mechanism (fallback path when FIFO has no reader) has no verification that tasks are actually received and processed by workers.

**Dispatch Chain (Current):**
```
User Input -> Bridge Parse -> tmux send-keys -> (NO VERIFICATION) -> ?
```

**What Happens:**
1. Bridge sends `TASK: <prompt>` via `tmux send-keys`
2. tmux returns success (text sent to pane buffer)
3. Bridge moves on to next task
4. Worker Claude may or may not see/process the text
5. No ACK, no timeout, no retry

**Why "Only Master Replies":**
- Master receives FIFO/dispatch confirmation
- Workers never confirm task receipt
- Bridge assumes success and user sees master confirmation
- Worker task is lost in pane buffer or ignored by Claude

**Evidence Location:** `claude_bridge.py:519-534`

```python
if self.direct_fallback:
    pane_id = self._dispatch_to_worker(task)
    if pane_id:
        # Visual confirmation only - no worker ACK verification
        dispatch_msg = f"[DISPATCHED->WORKER {pane_id}] {task[:60]}"
        self._send_keys(dispatch_msg)
```

---

## 5. Secondary Contributing Factors

### 5.1 No Worker Health State Tracking

Workers don't broadcast their READY/BUSY state to a location Bridge can check.

### 5.2 Claude Pane Input Processing is Opaque

Claude Code's CLI doesn't expose an API to verify:
- Is the pane currently processing a task?
- Did it receive the new input?
- What is the current context/state?

### 5.3 No Structured Task ID in Dispatch

FIFO dispatch doesn't propagate `bridge_task_id` to workers for correlation.

### 5.4 LineFilter May Hide Diagnostic Information

Aggressive pattern filtering makes it harder to debug what workers are actually outputting.

---

## 6. Recommended Fix Strategy

### Phase 2 Implementation Priority

| Priority | Item | Impact | Effort |
|----------|------|--------|--------|
| **P0** | Add ACK Detection | Verifies worker received task | Medium |
| **P0** | Structured Phase Logging | Traceability from capture to dispatch | Low |
| **P0** | Retry with Worker Failover | Recovery from unresponsive workers | Medium |
| **P1** | Bridge Task ID Generation | Unique ID per task for tracking | Low |
| **P1** | Dispatch Mode Explicit Tracking | Know FIFO vs Direct dispatch | Low |
| **P2** | Structured bridge.log Format | Better log analysis | Low |

### P0: ACK Detection (Critical)

```python
# Proposed flow:
def _dispatch_to_worker(self, task: str, bridge_task_id: str) -> bool:
    # 1. Capture worker pane baseline
    baseline = self._capture_pane(worker_pane)

    # 2. Send task with bridge_task_id
    payload = f"TASK: {task} [bridge-task-id:{bridge_task_id}]"
    self._send_text_to_pane(worker_pane, payload)

    # 3. Wait for ACK pattern
    for _ in range(ACK_TIMEOUT / POLL_INTERVAL):
        capture = self._capture_pane(worker_pane)
        if f"[ACK] {bridge_task_id}" in capture:
            return True  # ACK received
        sleep(POLL_INTERVAL)

    return False  # Timeout - trigger retry
```

### P0: Retry with Worker Failover

```python
# Proposed flow:
def _dispatch_with_retry(self, task: str) -> bool:
    bridge_task_id = generate_task_id()
    workers = get_worker_panes()

    for attempt in range(MAX_RETRIES):
        for worker in workers:
            # Try current worker N times before failover
            for retry in range(WORKER_MAX_RETRIES):
                if self._dispatch_to_worker(task, bridge_task_id):
                    return True  # Success
                log_status("RETRY", worker=worker, attempt=attempt)
                sleep(RETRY_DELAY)

            # Worker failed, try next
            worker = next_worker()

    log_status("FAILED", all_attempts=attempt * WORKER_MAX_RETRIES)
    return False
```

### P0: Structured Phase Logging

```json
// bridge.log format change:
{"ts":"2026-02-06T10:00:00.000Z","phase":"DISPATCHED","bridge_task_id":"br-1234567890-abc","task":"Fix bug","target_worker":"%4","attempt":1}
{"ts":"2026-02-06T10:00:00.340Z","phase":"ACKED","bridge_task_id":"br-1234567890-abc","latency_ms":340}
{"ts":"2026-02-06T10:00:02.000Z","phase":"RETRY","bridge_task_id":"br-1234567890-abc","reason":"timeout","attempt":2}
{"ts":"2026-02-06T10:00:05.000Z","phase":"FAILED","bridge_task_id":"br-1234567890-abc","reason":"all_workers_unavailable"}
```

---

## 7. Evidence Checklist

- [x] Code review of `claude_bridge.py` (668 lines)
- [x] Code review of `swarm_bridge.sh` (179 lines)
- [x] Code review of `swarm_layout_5.sh` (313 lines)
- [x] Code review of existing tests (517 lines)
- [x] Debug script created (`swarm_bridge_debug.sh`)
- [ ] **Run debug script to gather runtime evidence** (requires tmux + Claude Code)
- [ ] **Verify send-keys reachability** (tmux-level test)
- [ ] **Verify worker ACK capability** (behavior test)

---

## 8. Next Steps

### Immediate (Before Phase 2)

1. **Run debug script** in environment with tmux + Claude Code CLI:
   ```bash
   ./scripts/swarm_bridge_debug.sh
   ```

2. **Analyze send-keys reachability results**:
   - If markers NOT FOUND in pane: tmux send-keys issue
   - If markers FOUND but no ACK: Claude not processing injected text

3. **Analyze worker ACK test results**:
   - If ECHO_ONLY: Claude echoes but doesn't process
   - If NO response: Claude ignoring injected TASK: format

### Phase 2 Deliverables

1. `BridgeTaskIdGenerator` class for unique task IDs
2. `_wait_for_ack()` method for ACK detection
3. Retry logic with worker failover
4. Structured phase logging (CAPTURED → DISPATCHED → ACKED → RETRY → FAILED)
5. Updated tests with ACK scenarios

---

## Appendix: Key Code References

| File | Lines | Description |
|------|-------|-------------|
| `claude_bridge.py` | 44-108 | LineFilter - output filtering |
| `claude_bridge.py` | 111-193 | DedupeState - deduplication |
| `claude_bridge.py` | 196-250 | TaskParser - task parsing |
| `claude_bridge.py` | 253-658 | ClaudeBridge - main bridge logic |
| `claude_bridge.py` | 370-403 | _send_keys - master confirmation |
| `claude_bridge.py` | 428-447 | _send_text_to_pane - worker dispatch |
| `claude_bridge.py` | 449-472 | _get_worker_panes - worker discovery |
| `claude_bridge.py` | 474-492 | _dispatch_to_worker - direct dispatch |
| `claude_bridge.py` | 494-544 | _write_to_fifo - FIFO + fallback path |
| `claude_bridge.py` | 546-582 | _log_status - logging |

---

*Report generated by GSD Execution Agent*
*Phase 1 v1.93 Milestone*
