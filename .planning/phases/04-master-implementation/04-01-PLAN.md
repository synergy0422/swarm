---
phase: 04-master-implementation
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - /home/user/AAA/swarm/swarm/master_scanner.py
  - /home/user/AAA/swarm/tests/test_master_scanner.py
autonomous: true
user_setup: []
must_haves:
  truths:
    - Master can read worker status from status.log (JSONL)
    - Master can read task lock state from locks directory
    - Master can capture tmux pane output for WAIT detection
    - Master runs a main loop with configurable poll interval
  artifacts:
    - path: /home/user/AAA/swarm/swarm/master_scanner.py
      provides: MasterScanner class with scan_loop, read_worker_status, read_lock_state methods
      min_lines: 100
    - path: /home/user/AAA/swarm/tests/test_master_scanner.py
      provides: Unit tests for scanner with isolated_swarm_dir fixture
      min_lines: 80
  key_links:
    - from: master_scanner.py
      to: status_broadcaster.py
      via: reads status.log for worker state
    - from: master_scanner.py
      to: task_lock.py
      via: checks locks/ for task lock state
    - from: master_scanner.py
      to: tmux_manager.py
      via: capture_agent_output for pane content
---

<objective>
**Goal:** Implement Master Scanner module for periodic worker and task lock scanning.

**Purpose:** Master needs to continuously monitor all workers' status and task locks to enable task dispatch and error detection.

**Output:**
- `/home/user/AAA/swarm/swarm/master_scanner.py` - MasterScanner class with scan_loop, status reading, lock checking
- `/home/user/AAA/swarm/tests/test_master_scanner.py` - Unit tests for scanner functionality
</objective>

<context>
@/home/user/AAA/swarm/.planning/STATE.md
@/home/user/AAA/swarm/.planning/phases/04-master-implementation/04-CONTEXT.md
@/home/user/AAA/swarm/swarm/status_broadcaster.py - BroadcastState enum, JSONL format
@/home/user/AAA/swarm/swarm/task_lock.py - TaskLockManager, LockInfo
@/home/user/AAA/swarm/swarm/tmux_manager.py - capture_agent_output method
@/home/user/AAA/swarm/tests/conftest.py - isolated_swarm_dir fixture

**Critical patterns to follow:**
- `get_ai_swarm_dir()` for env var with default `/tmp/ai_swarm`
- `os.path.join()` for all path construction
- `os.makedirs(path, exist_ok=True)` for auto-create
- `AI_SWARM_POLL_INTERVAL` env var (default 1.0) for scan frequency
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MasterScanner class structure</name>
  <files>/home/user/AAA/swarm/swarm/master_scanner.py</files>
  <action>
Create `master_scanner.py` with:

1. **Constants** at module level:
   - `DEFAULT_POLL_INTERVAL = 1.0`
   - `ENV_POLL_INTERVAL = 'AI_SWARM_POLL_INTERVAL'`

2. **Helper functions:**
   - `get_poll_interval() -> float` - reads env var or returns default
   - `get_ai_swarm_dir() -> str` - reused from status_broadcaster pattern

3. **WorkerStatus dataclass** with fields:
   - `worker_id: str`
   - `state: Optional[str]` - from status.log
   - `task_id: Optional[str]`
   - `timestamp: Optional[str]`
   - `message: Optional[str]`

4. **MasterScanner class** with:
   - `__init__(self, cluster_id: str)` - stores cluster_id, initializes paths
   - `_get_status_log_path() -> str` - returns path to status.log
   - `_get_locks_dir() -> str` - returns path to locks directory
   - `read_worker_status() -> List[WorkerStatus]` - parses status.log, returns last status per worker
   - `read_lock_state(task_id: str) -> Optional[LockInfo]` - uses task_lock module
   - `get_pane_output(agent_id: str) -> str` - calls tmux_manager.capture_agent_output

Do NOT implement scan_loop yet (Task 2).
  </action>
  <verify>
`python -c "from swarm.master_scanner import MasterScanner, WorkerStatus, get_poll_interval; print('MasterScanner imports OK')"`
  </verify>
  <done>
MasterScanner class exists with read_worker_status(), read_lock_state(), get_pane_output() methods
</done>
</task>

<task type="auto">
  <name>Task 2: Implement scan_loop main loop</name>
  <files>/home/user/AAA/swarm/swarm/master_scanner.py</files>
  <action>
Add to MasterScanner class:

1. **scan_loop() async method:**
   - Takes `stop_event: threading.Event` for graceful shutdown
   - Loop while not stop_event.is_set():
     - Call `scan_all()` to scan workers and locks
     - Sleep `get_poll_interval()` seconds (default 1.0)
   - Returns when stop_event is set

2. **scan_all() method:**
   - Calls `read_worker_status()` for all workers
   - Returns dict: `{worker_id: WorkerStatus, ...}`
   - This is the main scan operation called each iteration

3. **Module-level convenience function:**
   - `create_scanner(cluster_id: str) -> MasterScanner` - factory function

Add imports: `threading`, `typing`, `json`, `os`, `datetime`, `timezone`
  </action>
  <verify>
`python -c "from swarm.master_scanner import create_scanner; s = create_scanner('test'); print('Scanner created OK')"`
  </verify>
  <done>
MasterScanner has working scan_loop() with configurable poll interval
</done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for MasterScanner</name>
  <files>/home/user/AAA/swarm/tests/test_master_scanner.py</files>
  <action>
Create test file following test_status_broadcaster.py patterns:

1. **Test class:** `TestMasterScanner(unittest.TestCase)`

2. **Test cases:**
   - `test_read_worker_status_empty_log` - handles empty status.log
   - `test_read_worker_status_single_entry` - parses single JSONL line
   - `test_read_worker_status_multiple_workers` - returns last status per worker
   - `test_read_lock_state_nonexistent` - returns None for unlocked task
   - `test_read_lock_state_locked` - returns LockInfo for locked task
   - `test_get_poll_interval_default` - returns 1.0 when env not set
   - `test_get_poll_interval_custom` - returns env value when set
   - `test_worker_status_dataclass` - verifies dataclass fields

Use `isolated_swarm_dir` fixture implicitly (autouse=True in conftest.py).

3. **Import pattern:**
   ```python
   from swarm import status_broadcaster, task_lock
   from swarm.master_scanner import MasterScanner, WorkerStatus
   ```
  </action>
  <verify>
`python -m pytest tests/test_master_scanner.py -v --tb=short` - all tests pass
  </verify>
  <done>
All 8+ unit tests for MasterScanner pass
</done>
</task>

</tasks>

<verification>
- MasterScanner imports successfully
- read_worker_status() correctly parses status.log JSONL
- read_lock_state() returns LockInfo for locked tasks
- scan_loop() runs with configurable poll interval
- All tests pass with isolated_swarm_dir fixture
</verification>

<success_criteria>
1. MasterScanner exists and can read status.log
2. MasterScanner can check task locks
3. scan_loop() runs at configurable frequency
4. 8+ unit tests covering scanner functionality
5. All tests pass (pytest)
</success_criteria>

<output>
After completion, create `.planning/phases/04-master-implementation/04-01-SUMMARY.md`
</output>
