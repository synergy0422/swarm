---
phase: 04-master-implementation
plan: '03'
type: execute
wave: 2
depends_on:
  - 04-01
  - 04-02
files_modified:
  - /home/user/AAA/swarm/swarm/master_dispatcher.py
  - /home/user/AAA/swarm/tests/test_master_dispatcher.py
  - /home/user/AAA/swarm/swarm/__init__.py
autonomous: true
user_setup: []
must_haves:
  truths:
    - Master can read task queue from tasks.json
    - Master dispatches tasks to idle workers using FIFO order
    - Task lock must be acquired before dispatch (atomic O_CREAT|O_EXCL)
    - Only idle workers (DONE/SKIP/ERROR state with no lock) receive tasks
  artifacts:
    - path: /home/user/AAA/swarm/swarm/master_dispatcher.py
      provides: MasterDispatcher class with dispatch_loop, dispatch_one, is_worker_idle
      min_lines: 120
    - path: /home/user/AAA/swarm/tests/test_master_dispatcher.py
      provides: Unit tests for dispatcher with task queue and lock integration
      min_lines: 100
    - path: /home/user/AAA/swarm/swarm/__init__.py
      provides: Exports for master_scanner, auto_rescuer, master_dispatcher
      min_lines: 30
  key_links:
    - from: master_dispatcher.py
      to: task_queue.py
      via: reads tasks.json for pending tasks
    - from: master_dispatcher.py
      to: task_lock.py
      via: acquires lock before dispatch (atomic)
    - from: master_dispatcher.py
      to: status_broadcaster.py
      via: broadcasts ASSIGNED state on dispatch
    - from: master_dispatcher.py
      to: master_scanner.py
      via: uses scanner to check worker idle status
---

<objective>
**Goal:** Implement Master Dispatcher module for FIFO task allocation to idle workers.

**Purpose:** Master must dispatch tasks from the queue to available workers, ensuring no duplicate execution via lock acquisition.

**Output:**
- `/home/user/AAA/swarm/swarm/master_dispatcher.py` - MasterDispatcher class with dispatch_loop, dispatch_one
- `/home/user/AAA/swarm/tests/test_master_dispatcher.py` - Unit tests for dispatcher
- `/home/user/AAA/swarm/swarm/__init__.py` - Updated exports for all modules
</objective>

<context>
@/home/user/AAA/swarm/.planning/phases/04-master-implementation/04-CONTEXT.md
@/home/user/AAA/swarm/swarm/task_queue.py - Task queue reading pattern
@/home/user/AAA/swarm/swarm/task_lock.py - TaskLockManager.acquire_lock
@/home/user/AAA/swarm/swarm/status_broadcaster.py - BroadcastState.ASSIGNED (new state)

**Dispatch algorithm (FIFO):**
1. Read tasks.json queue from head
2. Find first task without valid lock
3. Try to acquire lock (O_CREAT|O_EXCL)
4. If acquired -> dispatch, update status to ASSIGNED
5. If not acquired -> skip to next task

**Idle worker definition:**
- Status is DONE/SKIP/ERROR **AND** holds no active lock
- OR Heartbeat exists but no active task

**Task states from Phase 3:**
- START, DONE, WAIT, ERROR, HELP, SKIP
- ADD: ASSIGNED - task has been dispatched to worker

**Configuration:**
- `AI_SWARM_POLL_INTERVAL` - dispatch loop frequency (reuse from scanner)
- `AI_SWARM_LOCK_TTL` - lock timeout (reuse from task_lock)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MasterDispatcher class</name>
  <files>/home/user/AAA/swarm/swarm/master_dispatcher.py</files>
  <action>
Create `master_dispatcher.py` with:

1. **Constants:**
   - `DEFAULT_TASKS_FILE = 'tasks.json'`
   - `ENV_TASKS_FILE = 'AI_SWARM_TASKS_FILE'`

2. **TaskInfo dataclass:**
   - `task_id: str`
   - `command: str`
   - `priority: int`
   - `status: str` - pending, assigned, done, skipped

3. **DispatchResult dataclass:**
   - `success: bool`
   - `task_id: Optional[str]`
   - `worker_id: Optional[str]`
   - `reason: Optional[str]` - failure reason if not success

4. **MasterDispatcher class:**
   - `__init__(self, cluster_id: str)` - initialize with scanner and lock manager
   - `load_tasks() -> List[TaskInfo]` - read tasks.json
   - `is_worker_idle(worker_status: WorkerStatus) -> bool` - check idle criteria
   - `find_idle_worker(worker_statuses: Dict[str, WorkerStatus]) -> Optional[str]`
   - `dispatch_one(task: TaskInfo, worker_id: str) -> bool` - acquire lock and dispatch
   - `dispatch_all(worker_statuses: Dict[str, WorkerStatus]) -> List[DispatchResult]`
   - `dispatch_loop(stop_event: threading.Event, scanner: MasterScanner)` - main loop

5. **Broadcast ASSIGNED state:**
   - Add to BroadcastState enum in status_broadcaster.py:
     ```python
     ASSIGNED = 'ASSIGNED'
     ```
   - Add convenience method `broadcast_assigned()` to StatusBroadcaster

Requires importing from:
- `swarm.master_scanner import MasterScanner, WorkerStatus`
- `swarm.task_lock import TaskLockManager`
- `swarm.status_broadcaster import StatusBroadcaster, BroadcastState`
  </action>
  <verify>
`python -c "from swarm.master_dispatcher import MasterDispatcher, TaskInfo, DispatchResult; print('MasterDispatcher imports OK')"`
  </verify>
  <done>
MasterDispatcher class exists with dispatch_loop, dispatch_one, is_worker_idle methods
</done>
</task>

<task type="auto">
  <name>Task 2: Implement dispatch_loop and integrate with scanner</name>
  <files>/home/user/AAA/swarm/swarm/master_dispatcher.py</files>
  <action>
Add to MasterDispatcher class:

1. **dispatch_loop() async method:**
   ```python
   async def dispatch_loop(self, stop_event: threading.Event) -> None:
       """
       Main dispatch loop that runs continuously.

       Args:
           stop_event: Event to signal graceful shutdown
       """
       while not stop_event.is_set():
           # Get worker statuses from scanner
           worker_statuses = self.scanner.scan_all()

           # Find idle workers
           idle_workers = [
               wid for wid, ws in worker_statuses.items()
               if self.is_worker_idle(ws)
           ]

           # Dispatch to each idle worker
           for worker_id in idle_workers:
               result = self.dispatch_to_worker(worker_id, worker_statuses)
               if result.success:
                   # Log successful dispatch
                   pass

           # Sleep between iterations
           await asyncio.sleep(get_poll_interval())
   ```

2. **dispatch_to_worker() method:**
   - Takes worker_id and worker_statuses
   - Loads pending tasks from tasks.json
   - Finds first task without valid lock
   - Tries to acquire lock via TaskLockManager
   - If acquired: sends command to worker via tmux, broadcasts ASSIGNED
   - Returns DispatchResult

3. **Helper methods:**
   - `_mark_task_assigned(task_id: str, worker_id: str)` - updates internal state
   - `_send_to_worker(worker_id: str, command: str)` - uses tmux_manager.send_to_agent

4. **Import asyncio for async dispatch_loop**
  </action>
  <verify>
`python -c "from swarm.master_dispatcher import create_dispatcher; print('Dispatcher factory OK')"`
  </verify>
  <done>
MasterDispatcher dispatch_loop runs and dispatches tasks to idle workers
</done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for MasterDispatcher</name>
  <files>/home/user/AAA/swarm/tests/test_master_dispatcher.py</files>
  <action>
Create test file following test_status_broadcaster.py patterns:

1. **Test class:** `TestMasterDispatcher(unittest.TestCase)`

2. **Test cases:**
   - `test_load_tasks_from_json` - reads tasks.json with proper format
   - `test_is_worker_idle_done_no_lock` - DONE state with no lock = idle
   - `test_is_worker_idle_error_no_lock` - ERROR state with no lock = idle
   - `test_is_worker_idle_skip_no_lock` - SKIP state with no lock = idle
   - `test_is_worker_idle_busy` - worker with START state = not idle
   - `test_is_worker_idle_has_lock` - worker with DONE but holds lock = not idle
   - `test_dispatch_acquires_lock` - successful dispatch acquires lock
   - `test_dispatch_skips_locked_task` - skips task with valid lock
   - `test_dispatch_to_idle_worker` - dispatches to idle worker
   - `test_dispatch_result_structure` - DispatchResult has correct fields

3. **Setup tasks.json in temp dir:**
   ```python
   {
       "tasks": [
           {"task_id": "task-001", "command": "python run.py", "priority": 1, "status": "pending"},
           {"task_id": "task-002", "command": "python test.py", "priority": 2, "status": "pending"}
       ]
   }
   ```

4. **Mock dependencies:**
   - Mock scanner.scan_all() to return controlled worker statuses
   - Mock tmux_manager.send_to_agent() to verify dispatch

5. **Imports:**
   ```python
   from swarm.master_dispatcher import MasterDispatcher, TaskInfo, DispatchResult
   from swarm import task_lock
   ```
  </action>
  <verify>
`python -m pytest tests/test_master_dispatcher.py -v --tb=short` - all tests pass
  </verify>
  <done>
All 10+ unit tests for MasterDispatcher pass
</done>
</task>

<task type="auto">
  <name>Task 4: Update swarm/__init__.py exports</name>
  <files>/home/user/AAA/swarm/swarm/__init__.py</files>
  <action>
Update `swarm/__init__.py` to export all new modules:

```python
"""AI Swarm - Multi-agent coordination system."""

__version__ = "0.1.0"

# Core classes
from .status_broadcaster import StatusBroadcaster, BroadcastState
from .task_lock import TaskLockManager, LockInfo
from .tmux_manager import TmuxSwarmManager, AgentStatus, AgentPane

# Phase 4 - Master components
from .master_scanner import MasterScanner, WorkerStatus, create_scanner
from .auto_rescuer import AutoRescuer, WaitPatternDetector, WaitPattern, PatternCategory
from .master_dispatcher import MasterDispatcher, TaskInfo, DispatchResult, create_dispatcher

__all__ = [
    # Core
    "StatusBroadcaster",
    "BroadcastState",
    "TaskLockManager",
    "LockInfo",
    "TmuxSwarmManager",
    "AgentStatus",
    "AgentPane",
    # Master (Phase 4)
    "MasterScanner",
    "WorkerStatus",
    "create_scanner",
    "AutoRescuer",
    "WaitPatternDetector",
    "WaitPattern",
    "PatternCategory",
    "MasterDispatcher",
    "TaskInfo",
    "DispatchResult",
    "create_dispatcher",
]
```

Also add `ASSIGNED` to BroadcastState enum in status_broadcaster.py and add `broadcast_assigned()` convenience method.
  </action>
  <verify>
`python -c "from swarm import MasterScanner, AutoRescuer, MasterDispatcher; print('All exports OK')"`
  </verify>
  <done>
All Phase 4 modules exported from swarm package
</done>
</task>

</tasks>

<verification>
- MasterDispatcher imports successfully
- dispatch_loop runs and dispatches tasks
- Lock acquisition happens before dispatch
- Worker idle detection works correctly
- All tests pass
</verification>

<success_criteria>
1. MasterDispatcher dispatches tasks using FIFO + lock acquisition
2. Only idle workers (DONE/SKIP/ERROR with no lock) receive tasks
3. ASSIGNED state broadcasts on successful dispatch
4. 10+ unit tests covering dispatcher functionality
5. All Phase 4 modules exported from swarm package
</success_criteria>

<output>
After completion, create `.planning/phases/04-master-implementation/04-03-SUMMARY.md`
</output>
