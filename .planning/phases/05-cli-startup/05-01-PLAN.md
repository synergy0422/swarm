---
phase: 05-cli-startup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swarm/cli.py
  - swarm/__init__.py
  - setup.py
  - README.md
autonomous: true

must_haves:
  truths:
    - "User can run 'swarm init' to check dependencies and create directory structure"
    - "User can run 'swarm up' to launch tmux session with master + N workers"
    - "User can run 'swarm master' to launch only master process"
    - "User can run 'swarm worker --id 1' to launch single worker"
    - "User can run 'swarm status' to view tmux session and agent status"
    - "User can run 'swarm down' to terminate swarm tmux session"
  artifacts:
    - path: "swarm/cli.py"
      provides: "CLI entry point with argparse command routing"
      min_lines: 250
      exports: ["main", "cmd_init", "cmd_up", "cmd_master", "cmd_worker", "cmd_status", "cmd_down"]
    - path: "setup.py"
      provides: "Package configuration with console_scripts entry point"
      contains: "console_scripts"
    - path: "README.md"
      provides: "5-line usage section for quick start"
      contains: "Usage"
  key_links:
    - from: "swarm/cli.py"
      to: "swarm/master.py"
      via: "subprocess or module import"
      pattern: "master\\.main\\(|python.*master"
    - from: "swarm/cli.py"
      to: "swarm/worker_smart.py"
      via: "subprocess or module import"
      pattern: "worker.*\\.run\\(|python.*worker"
    - from: "swarm/cli.py"
      to: "libtmux"
      via: "import and session management"
      pattern: "import.*libtmux|tmux.*session"
---

<objective>
Create unified CLI tool for AI Swarm with init, up, master, worker, status, and down commands

Purpose: Provide simple, docker-compose-like interface for launching swarm clusters
Output: Working `swarm` command with tmux orchestration
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cli-startup/05-CONTEXT.md
@swarm/__init__.py
@swarm/config.py
@swarm/master_scanner.py
@swarm/worker_smart.py
@swarm/master.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI module with argparse structure and init command</name>
  <files>swarm/cli.py</files>
  <action>
Create `swarm/cli.py` with:

1. **Argparse structure:**
   - Main parser: `swarm [command] [options]`
   - Global flags: `--cluster-id` (default: "default"), `--workers` (default: 3)
   - Subcommands: init, up, master, worker, status, down

2. **cmd_init():**
   - Check libtmux installed (try import, print error if missing)
   - Check tmux binary available (shutil.which('tmux'))
   - Print environment variable checklist:
     * AI_SWARM_DIR (default: /tmp/ai_swarm)
     * ANTHROPIC_API_KEY or LLM_BASE_URL
   - Create AI_SWARM_DIR structure if missing: {status/, locks/, results/}
   - Print "Swarm initialized successfully" with directory path

3. **Preflight check function (used by all commands):**
   - Verify tmux installed
   - Verify libtmux available
   - Verify AI_SWARM_DIR exists or can be created
   - Print warnings for missing optional items (API key)

4. **Error handling:**
   - Use try/except around imports
   - Print friendly error messages
   - Exit with status codes (0 success, 1 error)

5. **Main entry:**
   - `def main():` entry point
   - Parse args, call appropriate cmd_* function
   - `if __name__ == '__main__': main()`

Do NOT use typer/click - use argparse only (lightweight dependency).

Reference existing patterns:
- config.py for API key checking
- task_queue.py for directory creation patterns
  </action>
  <verify>
Run: `python -m swarm.cli init`
Expected: Checks pass, directory created, success message printed
  </verify>
  <done>
"swarm init" command creates directory structure and validates dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement master and worker commands with direct execution</name>
  <files>swarm/cli.py</files>
  <action>
Add to `swarm/cli.py`:

1. **cmd_master(args):**
   - Import: `from swarm.master import main as master_main`
   - Call `master_main()` directly (blocks until KeyboardInterrupt)
   - Pass through cluster_id from args
   - Handle exceptions with try/except, print clean error messages

2. **cmd_worker(args):**
   - Import: `from swarm.worker_smart import SmartWorker`
   - Create `SmartWorker(name=f"worker-{args.id}")`
   - Call `worker.run()` method (blocks until done)
   - Handle exceptions with try/except

3. **Reference existing code:**
   - `swarm/master.py` main() block for execution pattern
   - `swarm/worker_smart.py` main() block for worker instantiation

Do NOT use subprocess - import and call directly for cleaner integration.

Workers should default to worker-1, worker-2 naming based on --id flag.
  </action>
  <verify>
Run: `python -m swarm.cli master` (should start master loop)
Run: `python -m swarm.cli worker --id 1` (should start worker)
  </verify>
  <done>
"swarm master" and "swarm worker --id N" commands launch respective processes
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement up command with tmux session orchestration</name>
  <files>swarm/cli.py</files>
  <action>
Add to `swarm/cli.py`:

1. **cmd_up(args):**
   - Import libtmux: `import libtmux`
   - Session name: `f"swarm-{args.cluster_id}"`

2. **Session creation logic:**
   - Check if session exists: `libtmux.Server().find_session(session_name)`
   - If exists: print warning, suggest `swarm down` first, exit
   - If not: create new session with libtmux

3. **Pane creation sequence:**
   - Create first pane (master): `session.new_window("master").attached_pane`
   - Send command: `pane.send_keys(f"swarm master --cluster-id {args.cluster_id}")`
   - For each worker i in range(args.workers):
     * Create new window: `session.new_window(f"worker-{i}")`
     * Send command: `pane.send_keys(f"swarm worker --id {i} --cluster-id {args.cluster_id}")`

4. **Success output:**
   - Print session name: `swarm-{args.cluster_id}`
   - Print attach command: `tmux attach -t swarm-{args.cluster_id}`
   - Print workers count
   - Print "Use 'swarm status' to check progress"

5. **Error handling:**
   - If libtmux fails: print error, try cleanup with `cmd_down(args)`
   - Catch exceptions, print clear messages

Reference TmuxSwarmManager patterns from tmux_manager.py for session handling.
  </action>
  <verify>
Run: `swarm up --workers 2`
Expected: Creates tmux session with master + 2 worker panes
  </verify>
  <done>
"swarm up" creates tmux session with master pane + N worker panes
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement status and down commands</name>
  <files>swarm/cli.py</files>
  <action>
Add to `swarm/cli.py`:

1. **cmd_status(args):**
   - Session name: `f"swarm-{args.cluster_id}"`
   - Use libtmux to find session
   - If not found: print "No swarm session running"
   - If found:
     * List all windows/panes with titles
     * Read status.log if exists: `f"{AI_SWARM_DIR}/status.log"`
     * Parse last 10 lines, show latest status per agent
     * Print active tasks from locks/ directory
   - Format: table-like output with columns (Agent, Status, Current Task)

2. **cmd_down(args):**
   - Session name: `f"swarm-{args.cluster_id}"`
   - Use libtmux to find session
   - If found: `session.kill_session()`
   - Print "Swarm session stopped: {session_name}"
   - If not found: print "No swarm session running"

3. **Helper functions:**
   - `get_session(cluster_id)` - returns libtmux Session or None
   - `parse_status_log()` - reads last N lines, returns dict of agent->status

4. **Error handling:**
   - Graceful handling of missing sessions
   - Clean error messages for permission issues

Reference StatusBroadcaster status.log format from status_broadcaster.py.
  </action>
  <verify>
Run: `swarm status` (after swarm up)
Expected: Shows session windows and agent statuses

Run: `swarm down`
Expected: Terminates tmux session, confirms shutdown
  </verify>
  <done>
"swarm status" displays tmux session and agent states, "swarm down" terminates session
  </done>
</task>

<task type="auto">
  <name>Task 5: Add setup.py with console_scripts and update README</name>
  <files>setup.py, README.md</files>
  <action>
1. **Create setup.py:**
   - Package name: "ai-swarm"
   - Version: "0.1.0"
   - Packages: ["swarm"]
   - Install requires: ["requests", "libtmux"]
   - Entry points:
     ```python
     console_scripts=[
         'swarm=swarm.cli:main',
     ],
     ```
   - Include README.md, LICENSE
   - Python 3.8+ required

2. **Update README.md:**
   Add "Usage" section at top:
   ```markdown
   ## Usage

   ```bash
   # Initialize swarm environment
   swarm init

   # Launch cluster (master + 3 workers)
   swarm up

   # Attach to tmux session
   tmux attach -t swarm-default

   # Check status
   swarm status

   # Stop cluster
   swarm down
   ```

   ## Requirements

   - Python 3.8+
   - tmux
   - libtmux (`pip install libtmux`)
   - ANTHROPIC_API_KEY or LLM_BASE_URL environment variable
   ```

3. **Export CLI from swarm/__init__.py:**
   - Add `'cli'` to __all__ list
   - Enables `python -m swarm.cli` usage

4. **Verify setup.py:**
   - Run `python setup.py --help` to validate
   - Run `pip install -e .` to test installation

Reference standard setup.py patterns for console_scripts entry points.
  </action>
  <verify>
Run: `python setup.py --help-commands | grep install`
Run: `pip install -e . && swarm --help` (should show usage)
Expected: setup.py valid, pip install succeeds, swarm command available
  </verify>
  <done>
"pip install -e ." installs swarm command globally, README shows 5-line usage
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **CLI structure:** All commands (init, up, master, worker, status, down) implemented
2. **Argparse only:** No typer/click imports, only argparse + standard lib
3. **Integration:** Commands correctly import and call existing modules
4. **Errors handled:** Missing dependencies handled with clear messages
5. **Documentation:** README has Usage section
6. **Installable:** setup.py creates console_scripts entry point
</verification>

<success_criteria>
Phase 5 complete when:
- `swarm init` validates dependencies and creates directories
- `swarm up` launches tmux session with master + N workers
- `swarm master` starts master process directly
- `swarm worker --id 1` starts single worker
- `swarm status` shows session and agent status
- `swarm down` terminates tmux session
- README.md has 5-line usage section
- setup.py installs `swarm` command globally
</success_criteria>

<output>
After completion, create `.planning/phases/05-cli-startup/05-01-SUMMARY.md`
</output>
