---
phase: "13-任务锁脚本"
plan: "01"
type: "execute"
wave: "1"
depends_on: []
files_modified: []
autonomous: true
---

# Phase 13: 任务锁脚本执行计划

## Goal

Create `swarm_lock.sh` CLI script for task lock management supporting atomic acquire/release/check/list operations.

## Success Criteria

1. `./scripts/swarm_lock.sh acquire task-001 worker-0` creates lock file and returns lock content
2. Lock exists → repeated acquire fails with error message
3. `./scripts/swarm_lock.sh release task-001 worker-0` successfully deletes lock when owner matches
4. After release, can re-acquire same task
5. `check <task_id>` shows active/expired status
6. `list` shows all locks with status
7. SWARM_STATE_DIR environment variable overrides default `/tmp/ai_swarm`

## Requirements (from ROADMAP)

- LOCK-01: Task lock script
- LOCK-02: Atomic lock acquisition
- LOCK-03: Lock release and verification

## Implementation Decisions

### Lock File Format

```
{
  "task_id": "task-001",
  "worker": "worker-0",
  "acquired_at": "2025-02-02T10:00:00Z",
  "expires_at": "2025-02-02T11:00:00Z"
}
```

- All 4 fields present in JSON format
- TTL is optional (no default value)
- User must explicitly provide TTL if they want lock expiry
- If expires_at is empty or not present → lock never expires (always Active)

### Command Specifications

| Command | Usage | Description |
|---------|-------|-------------|
| acquire | `acquire <task_id> <worker> [ttl_seconds]` | Atomically acquire task lock |
| release | `release <task_id> <worker>` | Release lock with strict owner validation |
| check | `check <task_id>` | Check lock exists and status (active/expired) |
| list | `list` | List all active locks |

### Behavioral Specifications

1. **Acquire:**
   - Use python os.open(..., O_CREAT|O_EXCL) for atomic lock creation
   - Fail immediately if lock exists (FileExistsError)
   - Error message + non-zero exit code on failure
   - Human readable success output with lock details
   - Expired locks can be overridden (new acquire replaces expired lock)

2. **Release:**
   - Strict validation: task_id AND worker must match the lock file content
   - Error message + non-zero exit code if worker mismatch
   - Output success message on valid release

3. **Check:**
   - Output: "No lock for task-001" if not exists
   - Output: status + details if exists (active/expired)

4. **List:**
   - List all .lock files in LOCK_DIR
   - Show status (active/expired) for each lock
   - Handle empty locks directory gracefully

### Path Configuration

- LOCK_DIR: `"${SWARM_STATE_DIR:-/tmp/ai_swarm}/locks"`
- SWARM_STATE_DIR environment variable overrides default `/tmp/ai_swarm`

## Tasks

<task type="auto">
### Create swarm_lock.sh script with basic structure

**File:** `/home/user/projects/AAA/swarm/scripts/swarm_lock.sh`

**Actions:**
- Add shebang: `#!/bin/bash`
- Add `set -euo pipefail` for error handling
- Define LOCK_DIR variable with SWARM_STATE_DIR support
- Create usage function with command examples
- Implement JSON escaping helper function
- Parse command line arguments (subcommand)

**Acceptance:**
- Script is executable (chmod +x)
- Running without arguments shows usage information
- Script exits with non-zero code for invalid usage
</task>

<task type="auto">
### Implement acquire subcommand

**File:** `/home/user/projects/AAA/swarm/scripts/swarm_lock.sh`

**Actions:**
- Implement `acquire <task_id> <worker> [ttl_seconds]`
- Validate task_id and worker are provided
- Calculate expires_at if ttl_seconds is provided
- Use atomic create pattern with python os.open(O_EXCL):
  ```python
  python3 - <<'PY'
  import os, json, sys
  lock_dir, task_id = sys.argv[1], sys.argv[2]
  lock_file = f"{lock_dir}/{task_id}.lock"
  try:
    fd = os.open(lock_file, os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
    with os.fdopen(fd, 'w') as f:
      f.write(json.dumps(lock_data))
    print("Lock acquired")
  except FileExistsError:
    print("Lock already exists")
    sys.exit(1)
  PY
  ```
  Call via: `python3 - "$LOCK_DIR" "$task_id" <<'PY' ... PY`
- Write JSON lock file with all 4 fields
- Output human-readable success message
- Handle error cases: missing arguments, lock exists

**Acceptance:**
- `swarm_lock.sh acquire task-001 worker-0` creates lock file
- `swarm_lock.sh acquire task-001 worker-0` (again) fails with error
- TTL argument works correctly
- Exit codes: 0 for success, 1 for error
</task>

<task type="auto">
### Implement release subcommand

**File:** `/home/user/projects/AAA/swarm/scripts/swarm_lock.sh`

**Actions:**
- Implement `release <task_id> <worker>`
- Check if lock file exists at `LOCK_DIR/<task_id>.lock`
- Read and parse existing lock JSON
- Verify worker field matches provided worker
- If mismatch: error message, exit 1
- If match: rm lock file, output success message

**Acceptance:**
- `swarm_lock.sh release task-001 worker-0` succeeds and deletes lock
- `swarm_lock.sh release task-001 wrong-worker` fails with error
- `swarm_lock.sh release task-nonexistent worker-0` fails with error
</task>

<task type="auto">
### Implement check subcommand

**File:** `/home/user/projects/AAA/swarm/scripts/swarm_lock.sh`

**Actions:**
- Implement `check <task_id>`
- Check if lock file exists at `LOCK_DIR/<task_id>.lock`
- If not exists: output "No lock for task-001"
- If exists: read JSON, parse expires_at
- Determine status: "Active" (not expired) or "Expired"
- Output lock details: worker, acquired_at, expires_at (if present)

**Acceptance:**
- `swarm_lock.sh check task-001` shows "No lock" for non-existent
- `swarm_lock.sh check task-001` shows status and details for existing
- Expired locks show "Expired" status
</task>

<task type="auto">
### Implement list subcommand

**File:** `/home/user/projects/AAA/swarm/scripts/swarm_lock.sh`

**Actions:**
- Implement `list` with no arguments
- Ensure lock directory exists
- List all `.lock` files in LOCK_DIR
- For each file: read JSON, check expiry, output status line
- Format: `task-id: Active/Expired (worker: xxx, acquired: xxx)`
- Handle empty locks directory (no output or "No locks")

**Acceptance:**
- `./scripts/swarm_lock.sh list` shows all locks with status
- Empty directory shows appropriate message
- Status correctly identifies active vs expired locks
</task>

<task type="checkpoint:human-verify">
### Verify all success criteria

**Actions:**

Run the following test sequence:

```bash
# Clean slate
rm -rf /tmp/ai_swarm/locks

# Test 1: Acquire creates lock
echo "Test 1: Acquire lock"
./scripts/swarm_lock.sh acquire task-001 worker-0
[ -f /tmp/ai_swarm/locks/task-001.lock ] && echo "PASS: Lock created" || echo "FAIL: Lock not created"

# Test 2: Acquire same task fails
echo "Test 2: Acquire existing lock (should fail)"
./scripts/swarm_lock.sh acquire task-001 worker-0
[ $? -ne 0 ] && echo "PASS: Acquire failed as expected" || echo "FAIL: Should have failed"

# Test 3: Check shows active
echo "Test 3: Check lock status"
./scripts/swarm_lock.sh check task-001 | grep -q "Active" && echo "PASS: Shows active" || echo "FAIL: Not active"

# Test 4: Release with correct worker
echo "Test 4: Release with correct worker"
./scripts/swarm_lock.sh release task-001 worker-0
[ ! -f /tmp/ai_swarm/locks/task-001.lock ] && echo "PASS: Lock deleted" || echo "FAIL: Lock not deleted"

# Test 5: Re-acquire after release
echo "Test 5: Re-acquire after release"
./scripts/swarm_lock.sh acquire task-001 worker-0
[ -f /tmp/ai_swarm/locks/task-001.lock ] && echo "PASS: Re-acquire succeeded" || echo "FAIL: Re-acquire failed"

# Test 6: Release with wrong worker fails
echo "Test 6: Release with wrong worker (should fail)"
./scripts/swarm_lock.sh release task-001 wrong-worker
[ $? -ne 0 ] && echo "PASS: Release failed as expected" || echo "FAIL: Should have failed"

# Test 7: List shows locks
echo "Test 7: List locks"
./scripts/swarm_lock.sh list | grep -q "task-001" && echo "PASS: List shows task" || echo "FAIL: List missing task"

# Test 8: TTL behavior
echo "Test 8: TTL with expiry"
rm -rf /tmp/ai_swarm/locks
./scripts/swarm_lock.sh acquire task-002 worker-0 1  # 1 second TTL
sleep 2
./scripts/swarm_lock.sh check task-002 | grep -q "Expired" && echo "PASS: Lock expired" || echo "FAIL: Lock not expired"

# Test 9: Expired lock can be re-acquired
echo "Test 9: Re-acquire expired lock"
./scripts/swarm_lock.sh acquire task-002 worker-0
[ -f /tmp/ai_swarm/locks/task-002.lock ] && echo "PASS: Expired lock replaced" || echo "FAIL: Could not replace"

# Cleanup
rm -rf /tmp/ai_swarm/locks

echo "Verification complete"
```

**Verification:**
- All tests pass (or document which fail and why)
- No swarm/*.py files were modified
- SWARM_STATE_DIR environment variable works
</task>

## must_haves

- [ ] Script can atomically acquire task locks
- [ ] Script can release locks with strict owner validation
- [ ] Script can check lock status (active/expired)
- [ ] Script can list all locks with status
- [ ] SWARM_STATE_DIR env var overrides default /tmp/ai_swarm
- [ ] No swarm/*.py files were modified

## key_links

```
swarm_lock.sh acquire ──────> /tmp/ai_swarm/locks/ (creates lock files)
swarm_lock.sh release ─────> /tmp/ai_swarm/locks/ (deletes lock files)
swarm_lock.sh check ───────> /tmp/ai_swarm/locks/ (reads lock status)
swarm_lock.sh list ────────> /tmp/ai_swarm/locks/ (lists all lock files)
```

## Dependencies

- None (Phase 13 is standalone)
- Can reference patterns from Phase 12 (`swarm_status_log.sh`)

## Notes

- Lock acquisition uses python os.open(..., O_CREAT|O_EXCL) for atomicity
- Platform-independent (no flock command dependency)
- JSON format for lock files (easy to parse and extend)
- Human-readable output by default (no --json flag required)
