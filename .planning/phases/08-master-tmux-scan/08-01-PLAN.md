---
phase: 08-master-tmux-scan
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /home/user/projects/AAA/swarm/swarm/master.py
  - /home/user/projects/AAA/swarm/swarm/cli.py
autonomous: true
must_haves:
  truths:
    - "Master can scan pane content for 'Press Enter' patterns"
    - "Detected patterns trigger automatic ENTER key with 30s cooldown per window"
    - "tmux unavailable is silently skipped, no errors raised"
  artifacts:
    - path: "/home/user/projects/AAA/swarm/swarm/master.py"
      provides: "WaitDetector.detect_in_pane(), PaneScanner, Master pane scanning loop"
      min_lines: 50
    - path: "/home/user/projects/AAA/swarm/tests/test_master_tmux_scan.py"
      provides: "Integration tests with tmux skipif marker"
      min_lines: 100
  key_links:
    - from: "/home/user/projects/AAA/swarm/swarm/master.py::Master.__init__"
      to: "/home/user/projects/AAA/swarm/swarm/tmux_collaboration.py::TmuxCollaboration"
      via: "Optional[TmuxCollaboration] injection"
    - from: "/home/user/projects/AAA/swarm/swarm/master.py::Master.run"
      to: "/home/user/projects/AAA/swarm/swarm/master.py::PaneScanner.scan_all()"
      via: "Independent 3s interval polling"
---

<objective>
Extend Master to scan tmux pane content and auto-send ENTER when "Press Enter" patterns are detected.

**Purpose:** Workers running in tmux windows may display "Press Enter to continue" prompts that block execution. This phase adds automatic detection and ENTER key sending to keep workers moving.

**Output:** Modified Master class with:
- `WaitDetector.detect_in_pane(content)` method for pattern detection
- `PaneScanner` class for capturing all window pane content
- Integrated pane scanning in Master main loop (3s interval)
- 30s cooldown per window to prevent repeated ENTERs
- Silent tmux unavailability handling
</objective>

<context>
@/home/user/projects/AAA/swarm/swarm/master.py
@/home/user/projects/AAA/swarm/swarm/tmux_collaboration.py
@/home/user/projects/AAA/swarm/.planning/phases/08-master-tmux-scan/08-CONTEXT.md

## Phase 7 Output (TmuxCollaboration)
- `TmuxCollaboration.capture_all_windows(session_name)` returns Dict[str, str] of window_name -> pane_content
- `TmuxCollaboration.send_keys_to_window(session_name, window_index, keys, enter=True)` sends keys

## Implementation Decisions (LOCKED)
| Decision | Value |
|----------|-------|
| Pane poll interval | 3 seconds (independent, configurable) |
| ENTER patterns | "press enter", "press return", "hit enter", "回车继续", "按回车" |
| Cooldown | 30 seconds per window |
| Logging | Minimal: `[Master] Auto-ENTER for {window_name}` |
| tmux unavailable | Silently skip, no errors |
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend WaitDetector with detect_in_pane() method</name>
  <files>/home/user/projects/AAA/swarm/swarm/master.py</files>
  <action>
Add `detect_in_pane(content: str) -> List[str]` method to `WaitDetector` class.

**Implementation:**
1. Add ENTER_PATTERNS list (only Priority 2 patterns):
   ```
   ENTER_PATTERNS = [
       r'[Pp]ress [Ee]nter',
       r'[Pp]ress [Rr]eturn',
       r'[Hh]it [Ee]nter',
       r'回车继续',
       r'按回车',
   ]
   ```
2. Method returns list of matching patterns found in content (for verification)
3. Keep existing `should_auto_confirm()` unchanged (it checks status.log message)

**DO NOT:**
- Add [y/n] patterns (Phase 9+)
- Add verbose logging
- Modify existing should_auto_confirm logic
</action>
  <verify>
Run: `python3 -c "from swarm.master import WaitDetector; d = WaitDetector(); print(d.detect_in_pane('Please press Enter to continue'))"`
- Should return: `['[Pp]ress [Ee]nter']` or similar match
</verify>
  <done>
WaitDetector.detect_in_pane() returns list of detected ENTER patterns from pane content
</done>
</task>

<task type="auto">
  <name>Task 2: Add PaneScanner class for window capture</name>
  <files>/home/user/projects/AAA/swarm/swarm/master.py</files>
  <action>
Add `PaneScanner` class to capture pane content from tmux windows.

**Implementation:**
```python
class PaneScanner:
    """Scans tmux pane content using TmuxCollaboration."""

    def __init__(self, tmux_collaboration: Optional['TmuxCollaboration'] = None):
        """Initialize with optional TmuxCollaboration for testing."""
        self.tmux = tmux_collaboration
        self._window_index_map: Dict[str, str] = {}  # window_name -> index

    def scan_all(self, session_name: str) -> Dict[str, str]:
        """Capture content from all windows.

        Returns:
            Dict mapping window_name to pane content.
            Empty dict if tmux unavailable.
        """
        if not self.tmux:
            return {}
        try:
            return self.tmux.capture_all_windows(session_name)
        except Exception:
            return {}

    def send_enter(self, session_name: str, window_name: str) -> bool:
        """Send ENTER key to a window by name.

        Returns:
            True if sent, False if window not found.
        """
        if not self.tmux:
            return False
        try:
            # Find window index by name
            windows = self.tmux.list_windows(session_name)
            for w in windows:
                if w["name"] == window_name:
                    self.tmux.send_keys_to_window(session_name, w["index"], "")
                    return True
            return False
        except Exception:
            return False
```

**Key behavior:**
- Gracefully handle tmux unavailability (return empty dict, no errors)
- Use list_windows() to map names to indices
- Swallow all exceptions silently
</action>
  <verify>
Run: `python3 -c "from swarm.master import PaneScanner; ps = PaneScanner(); print('PaneScanner created successfully')"`
</verify>
  <done>
PaneScanner class exists with scan_all() and send_enter() methods, handles tmux unavailability silently
</done>
</task>

<task type="auto">
  <name>Task 3: Integrate TmuxCollaboration into Master with pane scanning</name>
  <files>/home/user/projects/AAA/swarm/swarm/master.py</files>
  <action>
Modify `Master` class to inject TmuxCollaboration and scan panes.

**Changes to Master.__init__:**
1. Add optional `tmux_collaboration: Optional[TmuxCollaboration] = None` parameter
2. Add `pane_poll_interval: float = 3.0` parameter
3. Initialize `self.pane_scanner = PaneScanner(tmux_collaboration)`
4. Add `self._last_auto_enter: Dict[str, float] = {}` for 30s cooldown tracking
5. Add `self.cluster_id` for tmux session name

**Changes to Master.run:**
1. After step 3 (dispatch), add step 3.5: Scan panes and auto-ENTER
2. Call `self._handle_pane_wait_states()` on pane_poll_interval timing

**New method Master._handle_pane_wait_states:**
```python
def _handle_pane_wait_states(self):
    """Scan all panes and auto-send ENTER for detected patterns."""
    if not self.pane_scanner:
        return

    session_name = f"swarm-{self.cluster_id}"
    pane_contents = self.pane_scanner.scan_all(session_name)

    now = time.time()
    for window_name, content in pane_contents.items():
        patterns = self.wait_detector.detect_in_pane(content)

        if patterns:
            # Check cooldown
            last_enter = self._last_auto_enter.get(window_name, 0)
            if now - last_enter < 30:
                continue  # Still in cooldown

            # Send ENTER
            self.pane_scanner.send_enter(session_name, window_name)
            self._last_auto_enter[window_name] = now
            print(f"[Master] Auto-ENTER for {window_name}")
```

**Timing logic:**
- Use `time.time()` tracking: last_scan_time initialized to 0
- In run loop: if `now - last_scan_time >= self.pane_poll_interval`, scan panes
</action>
  <verify>
Run: `python3 -c "from swarm.master import Master; print('Master imported successfully')"`
- Verify no import errors
</verify>
  <done>
Master accepts optional TmuxCollaboration, has PaneScanner, and implements _handle_pane_wait_states with 30s cooldown
</done>
</task>

<task type="auto">
  <name>Task 4: Update CLI to inject TmuxCollaboration into Master</name>
  <files>/home/user/projects/AAA/swarm/swarm/cli.py</files>
  <action>
Modify `cmd_master()` in cli.py to create and inject TmuxCollaboration.

**Changes to cmd_master:**
```python
def cmd_master(args):
    try:
        from swarm.master import Master
        from swarm.tmux_collaboration import TmuxCollaboration

        print(f"[SWARM] Starting master for cluster: {args.cluster_id}")
        print("[SWARM] Press Ctrl+C to stop")

        # Create TmuxCollaboration if tmux is available
        tmux_collaboration = None
        try:
            tmux_collaboration = TmuxCollaboration()
            # Verify tmux is actually working by listing windows
            tmux_collaboration.list_windows(f"swarm-{args.cluster_id}")
        except Exception:
            # tmux not available, continue without it
            pass

        master = Master(
            cluster_id=args.cluster_id,
            tmux_collaboration=tmux_collaboration
        )
        master.run()
        return 0
```

**Key points:**
- Try/except around TmuxCollaboration creation
- Pass None if tmux unavailable (Master handles this gracefully)
- No changes to cmd_worker or other commands
</action>
  <verify>
Run: `python3 -c "from swarm.cli import cmd_master; print('cmd_master imported successfully')"`
</verify>
  <done>
cli.py creates TmuxCollaboration and passes to Master when available, handles tmux unavailability gracefully
</done>
</task>

<task type="auto">
  <name>Task 5: Create integration tests for Master pane scanning</name>
  <files>/home/user/projects/AAA/swarm/tests/test_master_tmux_scan.py</files>
  <action>
Create `tests/test_master_tmux_scan.py` with tmux skipif marker.

**File structure:**
```python
"""
Integration tests for Master pane scanning functionality.

Uses real tmux sessions when tmux is available, skips when not installed.
"""

import pytest
import shutil
import time
from datetime import datetime, timezone

# Skip if tmux not available
_tmux_available = shutil.which("tmux") is not None

pytestmark = pytest.mark.skipif(
    not _tmux_available,
    reason="tmux not installed"
)

# Import after skipif check
libtmux = pytest.importorskip("libtmux")
from swarm.master import Master, WaitDetector, PaneScanner
from swarm.tmux_collaboration import TmuxCollaboration


class TestWaitDetectorDetectInPane:
    """Tests for WaitDetector.detect_in_pane() method."""

    def test_detect_press_enter(self):
        """Verify 'Press Enter' pattern is detected."""
        detector = WaitDetector()
        content = "Please press Enter to continue..."
        patterns = detector.detect_in_pane(content)
        assert len(patterns) > 0
        assert any("enter" in p.lower() for p in patterns)

    def test_detect_press_return(self):
        """Verify 'Press Return' pattern is detected."""
        detector = WaitDetector()
        content = "Press Return when ready"
        patterns = detector.detect_in_pane(content)
        assert len(patterns) > 0

    def test_detect_chinese_patterns(self):
        """Verify Chinese patterns are detected."""
        detector = WaitDetector()
        content = "请按回车继续"
        patterns = detector.detect_in_pane(content)
        assert len(patterns) > 0

    def test_no_pattern_returns_empty(self):
        """Verify no pattern returns empty list."""
        detector = WaitDetector()
        content = "Task completed successfully"
        patterns = detector.detect_in_pane(content)
        assert patterns == []

    def test_case_insensitive(self):
        """Verify detection is case insensitive."""
        detector = WaitDetector()
        content = "PRESS ENTER TO CONTINUE"
        patterns = detector.detect_in_pane(content)
        assert len(patterns) > 0


class TestPaneScanner:
    """Tests for PaneScanner class."""

    @pytest.fixture
    def tmux(self):
        """Create TmuxCollaboration instance."""
        return TmuxCollaboration()

    @pytest.fixture
    def temp_session(self):
        """Create a temporary tmux session."""
        server = libtmux.Server()
        session_name = "test-master-scan"
        existing = server.sessions.get(session_name=session_name, default=None)
        if existing:
            existing.kill()
        session = server.new_session(session_name=session_name, attach=False)
        yield session
        session.kill()

    def test_scan_all_returns_dict(self, tmux, temp_session):
        """Verify scan_all returns dictionary."""
        scanner = PaneScanner(tmux)
        result = scanner.scan_all("test-master-scan")
        assert isinstance(result, dict)

    def test_scan_all_with_no_tmux(self):
        """Verify scan_all returns empty dict when no tmux."""
        scanner = PaneScanner(None)
        result = scanner.scan_all("nonexistent")
        assert result == {}

    def test_send_enter_to_window(self, tmux, temp_session):
        """Verify send_enter sends key to window."""
        scanner = PaneScanner(tmux)
        # Create a worker window
        temp_session.new_window(window_name="worker-0")

        # Send echo command
        scanner.send_enter("test-master-scan", "worker-0")

        time.sleep(0.1)
        # Verify no error (method returns True/False, doesn't raise)
        assert True  # If we got here, no exception


class TestMasterPaneScanning:
    """Integration tests for Master with pane scanning."""

    @pytest.fixture
    def tmux(self):
        """Create TmuxCollaboration instance."""
        return TmuxCollaboration()

    @pytest.fixture
    def temp_session(self):
        """Create a temporary tmux session."""
        server = libtmux.Server()
        session_name = "test-master-integration"
        existing = server.sessions.get(session_name=session_name, default=None)
        if existing:
            existing.kill()
        session = server.new_session(session_name=session_name, attach=False)
        yield session
        session.kill()

    def test_master_with_tmux_injection(self, tmux, temp_session):
        """Verify Master can be created with TmuxCollaboration."""
        # Create master with tmux
        master = Master(
            cluster_id="test-integration",
            tmux_collaboration=tmux,
            poll_interval=0.1
        )
        assert master.pane_scanner is not None

    def test_master_handles_missing_tmux_gracefully(self):
        """Verify Master works when tmux is None."""
        master = Master(
            cluster_id="test-none",
            tmux_collaboration=None,
            poll_interval=0.1
        )
        assert master.pane_scanner is not None

    def test_cooldown_tracking(self, tmux, temp_session):
        """Verify cooldown mechanism works."""
        master = Master(
            cluster_id="test-cooldown",
            tmux_collaboration=tmux,
            poll_interval=0.1,
            pane_poll_interval=0.1
        )

        # Add a fake last_auto_enter timestamp
        master._last_auto_enter["test-window"] = time.time()

        # Verify cooldown is tracked
        assert "test-window" in master._last_auto_enter


class TestCooldownMechanism:
    """Tests for 30-second cooldown per window."""

    def test_cooldown_prevents_repeated_enter(self):
        """Verify ENTER is not sent within 30s window."""
        from swarm.master import Master

        # Create master
        master = Master(
            cluster_id="test",
            tmux_collaboration=None,
            pane_poll_interval=0.01
        )

        # Simulate recent auto-enter
        master._last_auto_enter["window-1"] = time.time()

        # Check should_auto_enter helper
        now = time.time()
        last = master._last_auto_enter.get("window-1", 0)
        assert now - last < 30  # Within cooldown

    def test_cooldown_expired_allows_enter(self):
        """Verify ENTER is allowed after cooldown expires."""
        from swarm.master import Master

        master = Master(
            cluster_id="test",
            tmux_collaboration=None,
            pane_poll_interval=0.01
        )

        # Simulate old auto-enter (35 seconds ago)
        master._last_auto_enter["window-1"] = time.time() - 35

        now = time.time()
        last = master._last_auto_enter.get("window-1", 0)
        assert now - last >= 30  # Cooldown expired
```

**Test coverage:**
- WaitDetector.detect_in_pane() patterns
- PaneScanner scan_all() and send_enter()
- Master with TmuxCollaboration injection
- Cooldown mechanism
- tmux unavailability handling
</action>
  <verify>
Run: `python3 -m pytest tests/test_master_tmux_scan.py -v --tb=short` (when tmux available)
Run: `python3 -m pytest tests/test_master_tmux_scan.py -v --tb=short` (when tmux unavailable, should skip all tests)
</verify>
  <done>
test_master_tmux_scan.py exists with 100+ lines, all tests have skipif marker, tests pass (or skip gracefully when tmux unavailable)
</done>
</task>

<task type="auto">
  <name>Task 6: Run full test suite and verify</name>
  <files>/home/user/projects/AAA/swarm</files>
  <action>
Run comprehensive tests to verify the implementation:

1. Run the new integration tests:
   ```bash
   python3 -m pytest tests/test_master_tmux_scan.py -v
   ```

2. Run existing tests to ensure no regressions:
   ```bash
   python3 -m pytest tests/test_master*.py -v
   ```

3. Verify imports work correctly:
   ```bash
   python3 -c "from swarm.master import Master, WaitDetector, PaneScanner; from swarm.cli import cmd_master; print('All imports successful')"
   ```

4. Verify WaitDetector.detect_in_pane works:
   ```bash
   python3 -c "
   from swarm.master import WaitDetector
   d = WaitDetector()
   patterns = d.detect_in_pane('Please press Enter to continue')
   print(f'Detected patterns: {patterns}')
   assert len(patterns) > 0, 'Should detect press enter pattern'
   "
   ```

5. Verify PaneScanner handles None tmux:
   ```bash
   python3 -c "
   from swarm.master import PaneScanner
   ps = PaneScanner(None)
   result = ps.scan_all('any-session')
   assert result == {}, 'Should return empty dict when no tmux'
   print('PaneScanner handles None tmux correctly')
   "
   ```
</action>
  <verify>
All commands above execute successfully with expected output
</verify>
  <done>
All tests pass, imports work, and phase functionality is verified
</done>
</task>

</tasks>

<verification>
## Phase Verification Checklist

- [ ] WaitDetector.detect_in_pane() detects ENTER patterns (press enter, press return, hit enter, 回车继续, 按回车)
- [ ] PaneScanner.scan_all() returns Dict[str, str] of window_name -> pane_content
- [ ] PaneScanner.send_enter() sends ENTER to specific window by name
- [ ] Master accepts optional TmuxCollaboration in __init__
- [ ] Master._handle_pane_wait_states() scans panes and auto-sends ENTER
- [ ] 30-second cooldown prevents repeated ENTER per window
- [ ] tmux unavailable: silently skipped, no errors
- [ ] Minimal logging: `[Master] Auto-ENTER for {window_name}`
- [ ] cli.py passes TmuxCollaboration to Master when available
- [ ] tests/test_master_tmux_scan.py has 100+ lines with skipif marker
- [ ] All existing tests still pass (no regressions)
</verification>

<success_criteria>
- Phase 8 complete when:
  1. Master can scan tmux pane content for "Press Enter" patterns
  2. Detected patterns trigger automatic ENTER with 30s cooldown per window
  3. tmux unavailable is silently skipped (no errors)
  4. All tests pass (or skip gracefully when tmux unavailable)
  5. Existing test suite has no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/08-master-tmux-scan/08-01-SUMMARY.md` with:
- What was implemented
- Test results
- Any issues encountered
- Notes for next phase
</output>
