---
phase: 06-integration-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_auto_rescuer_patterns.py (new)
autonomous: true

must_haves:
  truths:
    - "Unit tests cover WaitPatternDetector pattern detection logic"
    - "Unit tests use mock tmux_manager (fast, CI-friendly)"
    - "Pattern detection is tested with various input formats (English, Chinese)"
    - "Blacklist keyword blocking is verified"
    - "Priority order of pattern detection is tested"
    - "Line count limit (20 lines) is tested"
  artifacts:
    - path: "tests/test_auto_rescuer_patterns.py"
      provides: "Unit tests for WaitPatternDetector and AutoRescuer pattern detection"
      min_lines: 180
      contains: ["test_interactive_confirm_priority", "test_press_enter_detection", "test_blacklist_blocking", "test_chinese_patterns", "test_line_count_limit"]
      marks: ["@pytest.mark.unit"]
  key_links:
    - from: "tests/test_auto_rescuer_patterns.py"
      to: "swarm/auto_rescuer.py"
      via: "Unit test imports and mocks"
      pattern: "WaitPatternDetector|AutoRescuer|PatternCategory"
    - from: "tests/test_auto_rescuer_patterns.py"
      to: "tests/test_auto_rescuer.py"
      via: "Extended test coverage patterns"
      pattern: "unittest\\.TestCase|mock|patch"
---

<objective>
Create comprehensive unit tests for auto-rescue pattern detection

Purpose: Test pattern detection logic with mock tmux_manager (fast, CI-friendly)
Output: tests/test_auto_rescuer_patterns.py with unit tests
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-integration-testing/06-CONTEXT.md
@tests/test_auto_rescuer.py (existing unit tests)
@swarm/auto_rescuer.py (WaitPatternDetector, AutoRescuer classes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_auto_rescuer_patterns.py with pytest structure</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Create `tests/test_auto_rescuer_patterns.py` with pytest structure:

1. **Imports:**
   ```python
   import pytest
   from datetime import datetime, timedelta
   from unittest.mock import Mock, patch, MagicMock
   from swarm.auto_rescuer import (
       AutoRescuer,
       WaitPatternDetector,
       WaitPattern,
       PatternCategory,
       DETECTION_LINE_COUNT,
       BLACKLIST_KEYWORDS
   )
   ```

2. **Module marker:**
   ```python
   pytestmark = pytest.mark.unit  # Not integration - uses mocks only
   ```

3. **Shared fixtures:**
   ```python
   @pytest.fixture
   def detector():
       """Fresh WaitPatternDetector for each test."""
       return WaitPatternDetector()

   @pytest.fixture
   def mock_tmux_manager():
       """Mock TmuxSwarmManager for AutoRescuer."""
       mock = Mock()
       mock_agent = Mock()
       mock_agent.pane.send_keys = Mock()
       mock._agents = {'test-worker': mock_agent}
       return mock

   @pytest.fixture
   def rescuer(mock_tmux_manager):
       """AutoRescuer with mock tmux manager."""
       return AutoRescuer(mock_tmux_manager)
   ```

4. **Test class organization:**
   - `TestWaitPatternDetector` - Pattern detection tests
   - `TestAutoRescuerIntegration` - AutoRescuer behavior tests
   - `TestPatternPriority` - Priority order verification
   - `TestBlacklistBlocking` - Blacklist keyword tests
   - `TestLineCountLimit` - Line count limit tests

Reference test_auto_rescuer.py for unittest patterns (can convert to pytest).
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py -v --collect-only`
Expected: All test classes and methods collected
  </verify>
  <done>
Test file created with pytest structure and fixtures
  </done>
</task>

<task type="auto">
  <name>Task 2: Test INTERACTIVE_CONFIRM pattern detection (y/n patterns)</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Add tests for interactive confirm pattern detection:

1. **test_detects_y_n_brackets:**
   ```python
   def test_detects_y_n_brackets(self, detector):
       """Test: detects [y/n] and [Y/n] patterns"""
       patterns = [
           "[y/n]",
           "[Y/n]",
           "[y/N]",
           "[Y/N]"
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.category == PatternCategory.INTERACTIVE_CONFIRM
           assert result.should_auto_confirm is False
   ```

2. **test_detects_parenthesized_y_n:**
   ```python
   def test_detects_parenthesized_y_n(self, detector):
       """Test: detects (y/n) patterns"""
       patterns = [
           "(y/n)",
           "(Y/n)",
           "Please confirm (y/n)"
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.category == PatternCategory.INTERACTIVE_CONFIRM
   ```

3. **test_detects_y_or_n_text:**
   ```python
   def test_detects_y_or_n_text(self, detector):
       """Test: detects 'y or n' text patterns"""
       patterns = [
           "y or n",
           "Y or n",
           "yes or no"
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.category == PatternCategory.INTERACTIVE_CONFIRM
   ```

4. **test_never_auto_confirms_interactive:**
   ```python
   def test_never_auto_confirms_interactive(self, detector):
       """Test: INTERACTIVE_CONFIRM always has should_auto_confirm=False"""
       for pattern in ["[y/n]", "(y/n)", "y or n"]:
           result = detector.detect(pattern, datetime.now())
           assert result.should_auto_confirm is False
   ```

Verify coverage of all patterns in _interactive_patterns list.
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py::TestWaitPatternDetector::test_detects_y_n_brackets -v`
Expected: Test passes for all bracket patterns
  </verify>
  <done>
INTERACTIVE_CONFIRM patterns ([y/n], (y/n)) correctly detected
  </done>
</task>

<task type="auto">
  <name>Task 3: Test PRESS_ENTER pattern detection</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Add tests for press enter pattern detection:

1. **test_detects_press_enter:**
   ```python
   def test_detects_press_enter(self, detector):
       """Test: detects 'Press ENTER' patterns"""
       patterns = [
           "Press ENTER to continue",
           "Press Enter to proceed",
           "Press RETURN to continue"
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.category == PatternCategory.PRESS_ENTER
           assert result.should_auto_confirm is True
   ```

2. **test_detects_hit_enter:**
   ```python
   def test_detects_hit_enter(self, detector):
       """Test: detects 'hit enter' patterns"""
       patterns = [
           "hit enter to continue",
           "Hit Enter to proceed"
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.category == PatternCategory.PRESS_ENTER
   ```

3. **test_detects_press_any_key:**
   ```python
   def test_detects_press_any_key(self, detector):
       """Test: detects 'press any key' patterns"""
       pattern = "Press any key to continue"
       result = detector.detect(pattern, datetime.now())
       assert result is not None
       assert result.category == PatternCategory.PRESS_ENTER
   ```

4. **test_press_enter_auto_confirm_safe:**
   ```python
   def test_press_enter_auto_confirm_safe(self, detector):
       """Test: PRESS_ENTER has should_auto_confirm=True (safe patterns)"""
       result = detector.detect("Press ENTER to continue", datetime.now())
       assert result.should_auto_confirm is True
   ```

Verify coverage of all patterns in _press_enter_patterns list.
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py::TestWaitPatternDetector::test_detects_press_enter -v`
Expected: All press enter patterns detected correctly
  </verify>
  <done>
PRESS_ENTER patterns correctly detected with auto-confirm=True
  </done>
</task>

<task type="auto">
  <name>Task 4: Test Chinese pattern detection</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Add tests for Chinese pattern detection:

1. **test_detects_chinese_press_enter:**
   ```python
   def test_detects_chinese_press_enter(self, detector):
       """Test: detects Chinese 'press enter' patterns"""
       patterns = [
           "按回车继续",      # Press enter to continue
           "回车继续",        # Press enter continue
           "请按回车键",      # Please press enter key
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.category == PatternCategory.PRESS_ENTER
           assert result.should_auto_confirm is True
   ```

2. **test_detects_chinese_confirm:**
   ```python
   def test_detects_chinese_confirm(self, detector):
       """Test: detects Chinese confirm patterns"""
       patterns = [
           "请确认操作",      # Please confirm operation
           "确定吗？",        # Are you sure?
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.category == PatternCategory.CONFIRM_PROMPT
   ```

3. **test_chinese_patterns_not_blacklisted:**
   ```python
   def test_chinese_patterns_not_blacklisted(self, detector):
       """Test: Chinese patterns without delete keywords auto-confirm"""
       pattern = "按回车继续"
       result = detector.detect(pattern, datetime.now())
       assert result.should_auto_confirm is True
   ```

Verify Chinese patterns in _press_enter_patterns and _confirm_patterns lists.
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py::TestWaitPatternDetector::test_detects_chinese_press_enter -v`
Expected: Chinese press enter patterns detected correctly
  </verify>
  <done>
Chinese patterns (按回车, 确认) correctly detected
  </done>
</task>

<task type="auto">
  <name>Task 5: Test blacklist keyword blocking</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Add tests for blacklist keyword blocking:

1. **test_blacklist_blocks_delete_patterns:**
   ```python
   def test_blacklist_blocks_delete_patterns(self, detector):
       """Test: 'delete' keyword blocks auto-confirm"""
       patterns = [
           "Press ENTER to delete all files",
           "Press ENTER to delete",
           "Press Enter to remove file"
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result is not None
           assert result.should_auto_confirm is False  # Blocked by blacklist
   ```

2. **test_blacklist_blocks_rm_rf:**
   ```python
   def test_blacklist_blocks_rm_rf(self, detector):
       """Test: 'rm -rf' blocks auto-confirm"""
       pattern = "Press enter to rm -rf /tmp/data"
       result = detector.detect(pattern, datetime.now())
       assert result.should_auto_confirm is False
   ```

3. **test_blacklist_blocks_sudo:**
   ```python
   def test_blacklist_blocks_sudo(self, detector):
       """Test: 'sudo' blocks auto-confirm"""
       pattern = "Press enter with sudo access"
       result = detector.detect(pattern, datetime.now())
       assert result.should_auto_confirm is False
   ```

4. **test_blacklist_blocks_password:**
   ```python
   def test_blacklist_blocks_password(self, detector):
       """Test: 'password' blocks auto-confirm"""
       pattern = "Enter password to continue"
       result = detector.detect(pattern, datetime.now())
       assert result is not None
       assert result.should_auto_confirm is False
   ```

5. **test_blacklist_blocks_prod:**
   ```python
   def test_blacklist_blocks_prod(self, detector):
       """Test: 'prod' or '生产' blocks auto-confirm"""
       patterns = [
           "Press enter for production deployment",
           "按回车确认生产环境"
       ]
       for pattern in patterns:
           result = detector.detect(pattern, datetime.now())
           assert result.should_auto_confirm is False
   ```

Verify BLACKLIST_KEYWORDS coverage.
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py::TestBlacklistBlocking -v`
Expected: All blacklist patterns block auto-confirm correctly
  </verify>
  <done>
Blacklist keywords (delete, rm -rf, sudo, password, prod) block auto-confirm
  </done>
</task>

<task type="auto">
  <name>Task 6: Test pattern priority order</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Add tests for pattern detection priority:

1. **test_interactive_has_priority_over_press_enter:**
   ```python
   def test_interactive_has_priority_over_press_enter(self, detector):
       """Test: [y/n] has priority over Press ENTER in same text"""
       text = "Continue? [y/n] or press ENTER to skip"
       result = detector.detect(text, datetime.now())
       assert result.category == PatternCategory.INTERACTIVE_CONFIRM
   ```

2. **test_press_enter_has_priority_over_confirm:**
   ```python
   def test_press_enter_has_priority_over_confirm(self, detector):
       """Test: Press ENTER has priority over confirm in same text"""
       text = "Press ENTER to confirm"
       result = detector.detect(text, datetime.now())
       assert result.category == PatternCategory.PRESS_ENTER
   ```

3. **test_first_match_wins_in_same_category:**
   ```python
   def test_first_match_wins_in_same_category(self, detector):
       """Test: First matching pattern in category is returned"""
       text = "Option 1: [y/n]\nOption 2: [Y/n]"
       result = detector.detect(text, datetime.now())
       assert result.matched_text == "[y/n]"
   ```

4. **test_priority_order_is_correct:**
   ```python
   def test_priority_order_is_correct(self, detector):
       """Test: Priority order: INTERACTIVE_CONFIRM > PRESS_ENTER > CONFIRM_PROMPT"""
       # All three in one text - should get INTERACTIVE_CONFIRM
       text = "[y/n] or Press ENTER to continue or confirm"
       result = detector.detect(text, datetime.now())
       assert result.category == PatternCategory.INTERACTIVE_CONFIRM
   ```

Verify detection priority: _check_interactive_confirm → _check_press_enter → _check_confirm_prompt.
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py::TestPatternPriority -v`
Expected: Priority order verified (interactive > press_enter > confirm)
  </verify>
  <done>
Pattern priority order: INTERACTIVE_CONFIRM > PRESS_ENTER > CONFIRM_PROMPT
  </done>
</task>

<task type="auto">
  <name>Task 7: Test line count limit (DETECTION_LINE_COUNT)</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Add tests for line count limit (note: time window not implemented):

1. **test_only_checks_last_20_lines:**
   ```python
   def test_only_checks_last_20_lines(self, detector):
       """Test: Only last 20 lines are checked for patterns"""
       # Create 25 lines of output with pattern in line 0
       lines = ["Normal line"] * 25
       lines[0] = "Press ENTER to continue"  # Should be ignored
       output = "\n".join(lines)

       result = detector.detect(output, datetime.now())
       assert result is None  # Pattern not in last 20 lines
   ```

2. **test_detects_pattern_in_last_20_lines:**
   ```python
   def test_detects_pattern_in_last_20_lines(self, detector):
       """Test: Pattern in last 20 lines is detected"""
       lines = ["Normal line"] * 25
       lines[22] = "Press ENTER to continue"  # Should be detected
       output = "\n".join(lines)

       result = detector.detect(output, datetime.now())
       assert result is not None
       assert result.category == PatternCategory.PRESS_ENTER
   ```

3. **test_empty_output_returns_none:**
   ```python
   def test_empty_output_returns_none(self, detector):
       """Test: Empty or None output returns None"""
       assert detector.detect("", datetime.now()) is None
       assert detector.detect(None, datetime.now()) is None
   ```

Note: `recent_threshold` parameter exists but time window filtering is not yet implemented.
Tests use datetime.now() as placeholder for API compatibility.
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py -k "line_count or empty" -v`
Expected: All limit tests pass
  </verify>
  <done>
Line count limits (20 lines) work correctly
  </done>
</task>

<task type="auto">
  <name>Task 8: Test AutoRescuer send_enter behavior</name>
  <files>tests/test_auto_rescuer_patterns.py</files>
  <action>
Add tests for AutoRescuer send_enter:

1. **test_send_enter_calls_pane_send_keys:**
   ```python
   def test_send_enter_calls_pane_send_keys(self, rescuer, mock_tmux_manager):
       """Test: send_enter calls pane.send_keys with empty string and enter=True"""
       result = rescuer.send_enter('test-worker')
       assert result is True
       mock_tmux_manager._agents['test-worker'].pane.send_keys.assert_called_once_with('', enter=True)
   ```

2. **test_send_enter_returns_false_for_unknown_agent:**
   ```python
   def test_send_enter_returns_false_for_unknown_agent(self, rescuer):
       """Test: send_enter returns False for unknown agent"""
       result = rescuer.send_enter('unknown-agent')
       assert result is False
   ```

3. **test_send_enter_handles_exception:**
   ```python
   def test_send_enter_handles_exception(self, rescuer, mock_tmux_manager):
       """Test: send_enter returns False on exception"""
       mock_tmux_manager._agents['test-worker'].pane.send_keys.side_effect = Exception("Pane dead")
       result = rescuer.send_enter('test-worker')
       assert result is False
   ```

4. **test_enabled_rescuer_sends_enter_for_press_enter:**
   ```python
   def test_enabled_rescuer_sends_enter_for_press_enter(self, rescuer, mock_tmux_manager):
       """Test: Enabled rescuer sends Enter for PRESS_ENTER pattern"""
       rescuer.enable()
       output = "Press ENTER to continue"

       pattern = rescuer.check_and_rescue('test-worker', output, datetime.now())

       assert pattern is not None
       mock_tmux_manager._agents['test-worker'].pane.send_keys.assert_called_once_with('', enter=True)
   ```

5. **test_disabled_rescuer_does_not_send_enter:**
   ```python
   def test_disabled_rescuer_does_not_send_enter(self, rescuer, mock_tmux_manager):
       """Test: Disabled rescuer does NOT send Enter (default behavior)"""
       # Disabled by default
       output = "Press ENTER to continue"

       pattern = rescuer.check_and_rescue('test-worker', output, datetime.now())

       assert pattern is not None
       mock_tmux_manager._agents['test-worker'].pane.send_keys.assert_not_called()
   ```

Verify AutoRescuer.enable()/disable() and is_enabled() work correctly.
  </action>
  <verify>
Run: `pytest tests/test_auto_rescuer_patterns.py::TestAutoRescuerIntegration -v`
Expected: All AutoRescuer integration tests pass
  </verify>
  <done>
AutoRescuer send_enter and enable/disable work correctly
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Test collection:** `pytest tests/test_auto_rescuer_patterns.py -v --collect-only` shows 20+ tests
2. **Unit tests pass:** `pytest tests/test_auto_rescuer_patterns.py -v` all pass
3. **Pattern coverage:** All patterns in auto_rescuer.py are tested:
   - INTERACTIVE_CONFIRM: [y/n], (y/n), y or n
   - PRESS_ENTER: Press ENTER, hit enter, 按回车
   - CONFIRM_PROMPT: confirm, are you sure, 确认
4. **Blacklist coverage:** All BLACKLIST_KEYWORDS tested
5. **Priority tests:** Priority order verified
6. **Line limits:** DETECTION_LINE_COUNT (20) tested
</verification>

<success_criteria>
Phase 6 Plan 02 complete when:
- tests/test_auto_rescuer_patterns.py exists with 180+ lines
- 20+ unit tests for pattern detection
- Tests use mock tmux_manager (fast, no real tmux needed)
- All unit tests pass without tmux
- Pattern detection, priority, and blacklist blocking verified
- Existing 159 unit tests still pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/06-integration-testing/06-02-SUMMARY.md`
</output>
