---
phase: 06-integration-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_e2e_happy_path.py (new)
autonomous: true

must_haves:
  truths:
    - "Single E2E test verifies CLI commands: swarm up → status → down"
    - "Test uses real tmux sessions with unique cluster_id for tmux isolation"
    - "Test uses isolated AI_SWARM_DIR (tmp_path/cluster_id) for file isolation"
    - "Test is marked @pytest.mark.integration to skip in normal test runs"
    - "Uses sys.executable -m swarm.cli for consistent CLI invocation"
    - "Test does NOT depend on LLM API keys or task execution"
  artifacts:
    - path: "tests/test_e2e_happy_path.py"
      provides: "E2E test for CLI command verification (no task execution)"
      min_lines: 100
      contains: ["test_cli_commands_work"]
      marks: ["@pytest.mark.integration"]
  key_links:
    - from: "tests/test_e2e_happy_path.py"
      to: "swarm/cli.py"
      via: "subprocess.run([sys.executable, '-m', 'swarm.cli', ...])"
      pattern: "sys\\.executable.*-m.*swarm\\.cli"
    - from: "tests/test_e2e_happy_path.py"
      to: "swarm/tmux_manager.py"
      via: "tmux session verification"
      pattern: "tmux|libtmux"
---

<objective>
Create E2E test for CLI command verification (no task execution)

Purpose: Verify swarm CLI commands work with real tmux sessions (1 test, no LLM dependency)
Output: tests/test_e2e_happy_path.py with one integrated test
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-integration-testing/06-CONTEXT.md
@tests/test_master_integration_smoke.py (reference pattern)
@tests/conftest.py (reference fixture)
@swarm/cli.py (reference commands)
@swarm/tmux_manager.py (reference tmux operations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_e2e_happy_path.py</name>
  <files>tests/test_e2e_happy_path.py</files>
  <action>
Create `tests/test_e2e_happy_path.py` with:

1. **Imports:**
   ```python
   import pytest
   import subprocess
   import sys
   import time
   import os
   import json
   import uuid
   import shutil
   ```

2. **Module marker and skip:**
   ```python
   pytestmark = pytest.mark.integration

   def check_tmux_available():
       """Skip test if tmux is not installed."""
       import shutil
       return shutil.which('tmux') is not None

   # Explicit skipif for clarity and CI compatibility
   pytestmark = pytest.mark.skipif(
       not check_tmux_available(),
       reason="tmux not installed - skipping integration test"
   )

3. **Test isolation fixtures:**
   ```python
   @pytest.fixture
   def unique_cluster_id():
       """Generate unique cluster ID for tmux session naming."""
       return f"test-happy-{uuid.uuid4().hex[:8]}"

   @pytest.fixture
   def isolated_swarm_dir(tmp_path, unique_cluster_id):
       """Create isolated AI_SWARM_DIR for this test."""
       swarm_dir = tmp_path / "ai_swarm" / unique_cluster_id
       swarm_dir.mkdir(parents=True, exist_ok=True)
       return str(swarm_dir)
   ```

4. **Helper: run_swarm_command:**
   ```python
   def run_swarm_command(cluster_id, command, args, swarm_dir):
       """Run swarm CLI with isolated AI_SWARM_DIR."""
       cmd = [sys.executable, '-m', 'swarm.cli', command,
              '--cluster-id', cluster_id] + args
       env = os.environ.copy()
       env['AI_SWARM_DIR'] = swarm_dir
       result = subprocess.run(cmd, capture_output=True, text=True, env=env)
       return result
   ```

5. **Helper: cleanup_cluster:**
   ```python
   def cleanup_cluster(cluster_id, swarm_dir):
       """Cleanup tmux session and files."""
       subprocess.run(['tmux', 'kill-session', '-t', f'swarm-{cluster_id}'],
                     capture_output=True)
       if os.path.exists(swarm_dir):
           shutil.rmtree(swarm_dir)
   ```

6. **Helper: session_exists:**
   ```python
   def session_exists(cluster_id):
       """Check if tmux session exists."""
       result = subprocess.run(
           ['tmux', 'has-session', '-t', f'swarm-{cluster_id}'],
           capture_output=True
       )
       return result.returncode == 0
   ```

7. **Helper: count_windows:**
   ```python
   def count_windows(cluster_id):
       """Count windows in tmux session (master + workers)."""
       result = subprocess.run(
           ['tmux', 'list-windows', '-t', f'swarm-{cluster_id}'],
           capture_output=True, text=True
       )
       if result.returncode != 0:
           return 0
       # Count lines (each window is one line)
       return len([l for l in result.stdout.strip().split('\n') if l])
   ```
  </action>
  <verify>
Run: `pytest tests/test_e2e_happy_path.py -v --collect-only`
Expected: Shows 1 test function collected (skipped if tmux not available)
  </verify>
  <done>
Test file created with proper isolation and helpers
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement test_cli_commands_work</name>
  <files>tests/test_e2e_happy_path.py</files>
  <action>
Add the CLI verification test:

```python
def test_cli_commands_work(unique_cluster_id, isolated_swarm_dir):
    """
    E2E test: Verify swarm CLI commands work with real tmux.

    This test verifies:
    1. swarm up creates tmux session with master + N workers
    2. swarm status displays session and window information
    3. swarm down terminates all sessions

    Note: This test does NOT execute real LLM tasks (no API key needed).
    It only verifies the CLI commands and tmux session lifecycle.
    """
    session_name = f"swarm-{unique_cluster_id}"
    workers = 2

    try:
        # === STEP 1: swarm up ===
        result = run_swarm_command(unique_cluster_id, 'up',
                                   ['--workers', str(workers)], isolated_swarm_dir)
        assert result.returncode == 0, f"swarm up failed: {result.stderr}"

        # Verify tmux session created
        assert session_exists(unique_cluster_id), \
            f"Session {session_name} not found after swarm up"

        # Verify windows: master + N workers
        window_count = count_windows(unique_cluster_id)
        assert window_count >= workers + 1, \
            f"Expected {workers + 1} windows (master + {workers} workers), got {window_count}"

        # Verify specific windows exist
        windows_output = subprocess.run(
            ['tmux', 'list-windows', '-t', session_name],
            capture_output=True, text=True
        )
        assert 'master' in windows_output.stdout
        for i in range(workers):
            assert f'worker-{i}' in windows_output.stdout, \
                f"worker-{i} window not found"

        # === STEP 2: swarm status ===
        result = run_swarm_command(unique_cluster_id, 'status', [], isolated_swarm_dir)
        assert result.returncode == 0, f"swarm status failed: {result.stderr}"

        # Status output should contain session name and window info
        assert session_name in result.stdout or 'master' in result.stdout, \
            f"Status output missing session info: {result.stdout}"

        # === STEP 3: swarm down ===
        result = run_swarm_command(unique_cluster_id, 'down', [], isolated_swarm_dir)
        assert result.returncode == 0, f"swarm down failed: {result.stderr}"

        # Verify session terminated
        assert not session_exists(unique_cluster_id), \
            f"Session {session_name} still exists after swarm down"

    finally:
        # Always cleanup to avoid leaving sessions
        cleanup_cluster(unique_cluster_id, isolated_swarm_dir)
```

Key points:
- Single test covers all 3 CLI commands (up, status, down)
- No LLM API key dependency
- No task execution or mailbox verification
- Uses try/finally for cleanup
- Verifies tmux session lifecycle only
  </action>
  <verify>
Run: `pytest tests/test_e2e_happy_path.py -v -s`
Expected: Test passes, all CLI commands work, session cleaned up
  </verify>
  <done>
CLI verification test implemented
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Test collection:** `pytest tests/test_e2e_happy_path.py -v --collect-only` shows 1 test
2. **Test runs:** `pytest tests/test_e2e_happy_path.py -v -m integration` runs the test
3. **CLI invocation:** Test uses `sys.executable -m swarm.cli`
4. **Isolation:** Test uses unique cluster_id + isolated AI_SWARM_DIR
5. **No API dependency:** Test does not require ANTHROPIC_API_KEY
6. **Cleanup:** Session always cleaned up in finally block
</verification>

<success_criteria>
Phase 6 Plan 01 complete when:
- tests/test_e2e_happy_path.py exists with 100+ lines
- 1 test covering CLI commands (up, status, down)
- Test marked @pytest.mark.integration (skipped by default)
- Uses sys.executable -m swarm.cli
- Uses isolated AI_SWARM_DIR
- Test passes with real tmux sessions
- No LLM API key dependency
</success_criteria>

<output>
After completion, create `.planning/phases/06-integration-testing/06-01-SUMMARY.md`
</output>
