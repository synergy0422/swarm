---
phase: 34-fifo-input-command-parsing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /home/user/projects/AAA/swarm/swarm/fifo_input.py
  - /home/user/projects/AAA/swarm/swarm/master.py
  - /home/user/projects/AAA/swarm/swarm/cli.py
  - /home/user/projects/AAA/swarm/scripts/swarm_fifo_write.sh
  - /home/user/projects/AAA/swarm/tests/test_fifo_input.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FIFO at $AI_SWARM_DIR/master_inbox exists when interactive mode enabled"
    - "Master does not block when reading from FIFO (uses O_NONBLOCK + select.poll)"
    - "FIFO write is non-blocking with O_NONBLOCK, returns error if no reader"
    - "Lines starting with /task create pending tasks"
    - "/task without prompt shows error, no empty tasks created"
    - "/help outputs command instructions"
    - "/quit stops input thread without stopping master"
    - "swarm task add command writes to FIFO"
    - "Natural language tasks appear in tasks.json"
    - "get_fifo_path() respects AI_SWARM_DIR (NOT AI_SWARM_TASKS_FILE)"
  artifacts:
    - path: /home/user/projects/AAA/swarm/swarm/fifo_input.py
      provides: "FifoInputHandler class with non-blocking read, own TaskQueue instance"
      exports: ["FifoInputHandler", "get_fifo_path()", "get_interactive_mode()"]
    - path: /home/user/projects/AAA/swarm/swarm/master.py
      provides: "Master.run() integrates FifoInputHandler when interactive enabled"
      imports: ["fifo_input"]
    - path: /home/user/projects/AAA/swarm/swarm/cli.py
      provides: "cmd_task_add() writes to FIFO, supports '-' for stdin"
      exports: ["cmd_task_add"]
    - path: /home/user/projects/AAA/swarm/scripts/swarm_fifo_write.sh
      provides: "Bash helper to write to FIFO"
      commands: ["write"]
    - path: /home/user/projects/AAA/swarm/tests/test_fifo_input.py
      provides: "Unit tests with proper test isolation (no global state pollution)"
      coverage: fifo_input.py
  key_links:
    - from: /home/user/projects/AAA/swarm/swarm/fifo_input.py
      to: /home/user/projects/AAA/swarm/swarm/task_queue.py
      via: "self._task_queue = TaskQueue() internally"
      pattern: "TaskQueue\\(\\)"
    - from: /home/user/projects/AAA/swarm/swarm/master.py
      to: /home/user/projects/AAA/swarm/swarm/fifo_input.py
      via: "FifoInputHandler.run() in daemon thread"
      pattern: "threading\\.Thread\\(target=handler\\.run"
    - from: /home/user/projects/AAA/swarm/swarm/cli.py
      to: /home/user/projects/AAA/swarm/swarm/fifo_input.py
      via: "get_fifo_path() for write location"
      pattern: "get_fifo_path\\(\\)"
---

<objective>
Implement FIFO input channel and command parsing for master to accept natural language tasks via named pipe.

**Critical Fixes from Review:**
1. FifoInputHandler creates its own TaskQueue internally (not passed from Master)
2. Non-blocking read uses os.open() with O_NONBLOCK + select.poll()
3. INTERACTIVE_MODE is boolean (not string comparison)
4. /task without prompt shows error, no empty tasks
5. Tests use proper isolation (no global state pollution)
</objective>

<context>
@/home/user/projects/AAA/swarm/swarm/task_queue.py
- TaskQueue.add_task() signature at line 201
- Returns: str task_id (format: task_XXX)
- Params: prompt, system=None, max_tokens=None, model=None, priority=5
- TaskQueue() constructor uses AI_SWARM_DIR/AI_SWARM_TASKS_FILE env vars

@/home/user/projects/AAA/swarm/swarm/master.py
- Master.run() main loop at line 588
- Already has signal handlers for graceful shutdown
- Master.running flag controls loop

@/home/user/projects/AAA/swarm/swarm/cli.py
- cmd_task() at line 566 handles task subcommands
- _get_script_path() helper at line 696
- Pattern: use subprocess to call scripts

@/home/user/projects/AAA/swarm/scripts/_common.sh
- log_info(), log_warn(), log_error() output to stderr
- SWARM_STATE_DIR from env or /tmp/ai_swarm
</context>

<tasks>

<task type="auto">
  <name>FifoInputHandler class with non-blocking FIFO read/write and own TaskQueue</name>
  <files>/home/user/projects/AAA/swarm/swarm/fifo_input.py</files>
  <action>
Create /home/user/projects/AAA/swarm/swarm/fifo_input.py with:

1. **Helper functions** (NOT module-level constants):
   ```python
   import os
   import stat
   import sys
   import select
   import errno
   import time

   def get_fifo_path() -> str:
       """Get FIFO path, respects AI_SWARM_DIR env var (NOT AI_SWARM_TASKS_FILE)."""
       base_dir = os.environ.get('AI_SWARM_DIR', '/tmp/ai_swarm')
       return os.path.join(base_dir, 'master_inbox')

   def get_interactive_mode() -> bool:
       """Check if interactive mode is enabled."""
       return os.environ.get('AI_SWARM_INTERACTIVE', '0') == '1'

   def write_to_fifo_nonblocking(fifo_path: str, text: str) -> bool:
       """
       Write to FIFO with O_NONBLOCK.
       Returns True on success, False if no reader (EAGAIN/EWOULDBLOCK).
       Raises exception on other errors.
       """
       fd = os.open(fifo_path, os.O_WRONLY | os.O_NONBLOCK)
       try:
           os.write(fd, (text + '\n').encode('utf-8'))
           return True
       except OSError as e:
           if e.errno in (errno.EAGAIN, errno.EWOULDBLOCK):
               return False  # No reader
           raise
       finally:
           os.close(fd)
   ```

2. **Class FifoInputHandler**:
   ```python
   class FifoInputHandler:
       def __init__(self):
           self.running = True
           self.fifo_path = get_fifo_path()
           # FifoInputHandler creates its own TaskQueue (respects AI_SWARM_TASKS_FILE)
           from swarm.task_queue import TaskQueue
           self._task_queue = TaskQueue()
           self._broadcaster = None  # Set by Master if provided

       def _ensure_fifo_exists(self):
           """Create FIFO if not exists."""
           if not os.path.exists(self.fifo_path):
               os.mkfifo(self.fifo_path, mode=0o666)

       def _read_line_nonblocking(self) -> str:
           """
           Read from FIFO using O_NONBLOCK + select.poll().
           Returns empty string on timeout, EOF, or POLLHUP.
           Does NOT block indefinitely.
           """
           fd = None
           try:
               fd = os.open(self.fifo_path, os.O_RDONLY | os.O_NONBLOCK)
               # Clear O_NONBLOCK for poll (we want to know when data arrives)
               flags = fcntl.fcntl(fd, fcntl.F_GETFL)
               fcntl.fcntl(fd, fcntl.F_SETFL, flags & ~os.O_NONBLOCK)

               poll_obj = select.poll()
               poll_obj.register(fd, select.POLLIN)

               events = poll_obj.poll(1000)  # 1 second timeout

               if not events:
                   return ''  # Timeout, no data

               # Check for POLLHUP (hangup) - reader closed
               for event in events:
                   if event & (select.POLLHUP | select.POLLERR):
                       return ''  # Reader closed

               # Data available, read it
               try:
                   data = os.read(fd, 4096)
                   if not data:
                       return ''  # EOF
                   return data.decode('utf-8').rstrip('\n')
               except OSError as e:
                   if e.errno == errno.EAGAIN:
                       return ''  # No data available
                   raise
           except FileNotFoundError:
               return ''  # FIFO doesn't exist yet
           except (OSError, IOError) as e:
               if e.errno in (errno.EAGAIN, errno.EWOULDBLOCK):
                   return ''
               return ''
           finally:
               if fd is not None:
                   try:
                       os.close(fd)
                   except OSError:
                       pass

       def _parse_command(self, line: str) -> tuple:
           """
           Parse line and return (command, payload).
           Returns:
             ('task', prompt) for /task <prompt> or plain text
             ('help', None) for /help
             ('quit', None) for /quit
             ('ignore', None) for empty/whitespace
             ('error', msg) for /task without prompt
           """
           line = line.strip()
           if not line:
               return ('ignore', None)

           if line.startswith('/'):
               parts = line.split(None, 1)
               cmd = parts[0].lower()
               if cmd == '/task':
                   if len(parts) < 2 or not parts[1].strip():
                       return ('error', '/task requires a prompt')
                   return ('task', parts[1])
               elif cmd == '/help':
                   return ('help', None)
               elif cmd == '/quit':
                   return ('quit', None)
               else:
                   return ('error', f'Unknown command: {cmd}')

           # Plain text treated as task prompt
           return ('task', line)

       def _handle_task(self, prompt: str):
           """Call task_queue.add_task(prompt), log result."""
           if not prompt:
               return
           try:
               task_id = self._task_queue.add_task(prompt)
               # broadcast_start() signature: (task_id, message, meta=None)
               # Note: No worker_id parameter
               if self._broadcaster:
                   self._broadcaster.broadcast_start(task_id=task_id, message=f"FIFO: {prompt[:50]}")
               sys.stdout.write(f"[FIFO] Created task: {task_id}\n")
               sys.stdout.flush()
           except Exception as e:
               sys.stderr.write(f"[FIFO] Failed to create task: {e}\n")
               sys.stderr.flush()

       def _handle_help(self):
           """Print help text."""
           sys.stdout.write("""
=== FIFO Input Commands ===

/task <prompt>   Create a new task with the given prompt
/help            Show this help message
/quit            Stop the FIFO input thread (master continues)

Examples:
  /task Review PR #123 and leave comments
  /task Fix authentication bug in login module

Plain text (without /task prefix) is also treated as a task prompt.

Note: Use 'swarm task add "<prompt>"' from CLI or 'echo "<prompt>" | ./scripts/swarm_fifo_write.sh write -' to write to FIFO.
""")
           sys.stdout.flush()

       def run(self):
           """Main loop - read, parse, handle."""
           self._ensure_fifo_exists()
           sys.stdout.write(f"[FIFO] Input thread started, listening on {self.fifo_path}\n")
           sys.stdout.flush()

           while self.running:
               try:
                   line = self._read_line_nonblocking()
                   if line is None:
                       continue

                   cmd, payload = self._parse_command(line)

                   if cmd == 'ignore':
                       continue
                   elif cmd == 'task':
                       self._handle_task(payload)
                   elif cmd == 'help':
                       self._handle_help()
                   elif cmd == 'quit':
                       sys.stdout.write("[FIFO] Input thread stopping...\n")
                       sys.stdout.flush()
                       self.running = False
                   elif cmd == 'error':
                       sys.stderr.write(f"[FIFO] Error: {payload}\n")
                       sys.stderr.flush()

               except Exception as e:
                   sys.stderr.write(f"[FIFO] Error: {e}\n")
                   sys.stderr.flush()

           sys.stdout.write("[FIFO] Input thread stopped\n")
           sys.stdout.flush()

       def _shutdown(self):
           """Signal handler calls this to stop the input thread."""
           self.running = False
   ```

3. **Key design decisions:**
   - FifoInputHandler creates its own TaskQueue internally (respects AI_SWARM_TASKS_FILE)
   - _read_line_nonblocking() uses os.open() with O_NONBLOCK, clears flag for poll(), handles POLLHUP
   - write_to_fifo_nonblocking() uses O_NONBLOCK write, returns False if no reader
   - /task without prompt returns ('error', msg), no empty task created
   - get_fifo_path() only uses AI_SWARM_DIR (NOT AI_SWARM_TASKS_FILE)
   - broadcast_start() only passes task_id and message (no worker_id)
</action>
  <verify>pytest tests/test_fifo_input.py -v --tb=short 2>&1 | head -60</verify>
  <done>FifoInputHandler uses O_NONBLOCK for read/write, handles POLLHUP, correct broadcast_start() signature</done>
</task>

<task type="auto">
  <name>Integrate FifoInputHandler into Master</name>
  <files>/home/user/projects/AAA/swarm/swarm/master.py</files>
  <action>
Modify /home/user/projects/AAA/swarm/swarm/master.py:

1. **Add imports**:
   ```python
   import threading
   from swarm.fifo_input import FifoInputHandler, get_interactive_mode
   ```

2. **Modify Master.__init__()**:
   ```python
   def __init__(self, ...):
       # ... existing code ...
       self.fifo_handler: Optional[FifoInputHandler] = None

       # Create FIFO handler if interactive mode enabled
       if get_interactive_mode():
           self.fifo_handler = FifoInputHandler()
           self.fifo_handler._ensure_fifo_exists()
   ```

3. **Modify Master.run()** (after print "[Master] Starting..."):
   ```python
   # Start FIFO input thread if interactive mode enabled
   fifo_thread = None
   if self.fifo_handler:
       # Set broadcaster for logging
       self.fifo_handler._broadcaster = self.broadcaster

       fifo_thread = threading.Thread(
           target=self.fifo_handler.run,
           daemon=True,
           name='FifoInputHandler'
       )
       fifo_thread.start()
       print(f"[Master] FIFO input thread started (interactive mode)")
   ```

4. **Modify Master._shutdown()**:
   ```python
   def _shutdown(self, signum, frame):
       print(f"\n[Master] Received signal {signum}, shutting down...")
       if self.fifo_handler:
           self.fifo_handler._shutdown()
       self.running = False
   ```

5. **Important**: FifoInputHandler.running and Master.running are INDEPENDENT
   - /quit only stops FifoInputHandler (handler.running = False)
   - Master continues running until Ctrl+C
</action>
  <verify>python3 -c "
from swarm.master import Master
from swarm.fifo_input import get_interactive_mode
print('Master imports FifoInputHandler OK')
print(f'get_interactive_mode() returns: {get_interactive_mode()}')"</verify>
  <done>Master starts FIFO input thread when AI_SWARM_INTERACTIVE=1, /quit only stops input thread</done>
</task>

<task type="auto">
  <name>Add swarm task add CLI command with non-blocking FIFO write</name>
  <files>/home/user/projects/AAA/swarm/swarm/cli.py</files>
  <action>
Modify /home/user/projects/AAA/swarm/swarm/cli.py:

1. **Add cmd_task_add() function with O_NONBLOCK write**:
   ```python
   def cmd_task_add(args):
       """
       Write task prompt to FIFO for master to pick up.
       Exit codes: 0=success, 1=error (FIFO not found, no reader, etc.)

       Usage:
         swarm task add "prompt text"      # From argument
         swarm task add -                   # From stdin
         echo "text" | swarm task add -    # Piped stdin
       """
       from swarm.fifo_input import get_fifo_path, write_to_fifo_nonblocking
       import sys

       fifo_path = get_fifo_path()

       # Determine prompt source
       prompt = None

       # Check for stdin flag '-'
       if hasattr(args, 'stdin_flag') and args.stdin_flag:
           prompt = sys.stdin.read().strip()
       elif args.prompt:
           prompt = args.prompt
       else:
           # No arg, try reading from stdin (non-blocking check)
           if not sys.stdin.isatty():
               prompt = sys.stdin.read().strip()

       if not prompt:
           print("[ERROR] No prompt provided", file=sys.stderr)
           print("[ERROR] Usage: swarm task add \"<prompt>\" OR echo \"<prompt>\" | swarm task add -", file=sys.stderr)
           return 1

       # Write to FIFO with non-blocking (won't hang if no reader)
       try:
           success = write_to_fifo_nonblocking(fifo_path, prompt)
           if not success:
               print(f"[ERROR] No reader on FIFO (is master running with AI_SWARM_INTERACTIVE=1?)", file=sys.stderr)
               return 1
       except FileNotFoundError:
           print(f"[ERROR] FIFO not found: {fifo_path}", file=sys.stderr)
           print("[ERROR] Is master running with AI_SWARM_INTERACTIVE=1?", file=sys.stderr)
           return 1
       except BrokenPipeError:
           print("[ERROR] FIFO write failed (reader closed?)", file=sys.stderr)
           return 1
       except Exception as e:
           print(f"[ERROR] FIFO write failed: {e}", file=sys.stderr)
           return 1

       print(f"[OK] Task written to FIFO: {prompt[:50]}...")
       return 0
   ```

2. **Modify cmd_task()** to handle 'add' subcommand (same as before)
3. **Update help text** in cmd_task() - add to usage list:
   - `add "<prompt>"   Add task via FIFO (or use - for stdin)`
</action>
  <verify>python3 -m swarm.cli task add --help</verify>
  <done>swarm task add command writes to FIFO with O_NONBLOCK, returns error if no reader</done>
</task>

<task type="auto">
  <name>Create swarm_fifo_write.sh helper with non-blocking FIFO write</name>
  <files>/home/user/projects/AAA/swarm/scripts/swarm_fifo_write.sh</files>
  <action>
Create /home/user/projects/AAA/swarm/scripts/swarm_fifo_write.sh with O_NONBLOCK write:

```bash
#!/usr/bin/env bash
set -euo pipefail

# Source common functions and config
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/_common.sh" || true

log_info() { echo "[$(date +%H:%M:%S)][INFO] $*" >&2; }
log_error() { echo "[$(date +%H:%M:%S)][ERROR] $*" >&2; }

# Get FIFO path dynamically (uses AI_SWARM_DIR only)
get_fifo_path() {
    echo "${AI_SWARM_DIR:-/tmp/ai_swarm}/master_inbox"
}

# Non-blocking write to FIFO
# Returns 0 on success, 1 if no reader, 2 on other errors
write_fifo_nonblocking() {
    local fifo_path="$1"
    local text="$2"

    # Check if FIFO exists
    if [[ ! -p "$fifo_path" ]]; then
        return 2
    fi

    # Use Python for O_NONBLOCK write (bash doesn't have native support)
    python3 -c "
import os
import sys
import errno

fifo_path = sys.argv[1]
text = sys.argv[2]

try:
    fd = os.open(fifo_path, os.O_WRONLY | os.O_NONBLOCK)
    os.write(fd, (text + '\n').encode('utf-8'))
    os.close(fd)
    sys.exit(0)  # Success
except OSError as e:
    if e.errno in (errno.EAGAIN, errno.EWOULDBLOCK):
        sys.exit(1)  # No reader
    sys.exit(2)  # Other error
" "$fifo_path" "$text"
}

usage() {
    cat << EOF
Usage: $(basename "\$0") <command> [args]

Write task prompts to the master FIFO input channel.

Commands:
  write "<prompt>"  Write a single task prompt to FIFO
  write -           Read prompt from stdin
  help              Show this help message

Examples:
  \$(basename "\$0") write "Review PR #123"
  \$(basename "\$0") write - < input.txt
  echo "Task desc" | \$(basename "\$0") write -

Note: Uses non-blocking write - returns error if no reader.

Environment:
  AI_SWARM_DIR     Directory for swarm state (default: /tmp/ai_swarm)
EOF
}

cmd_write() {
    local prompt=""

    # Check for stdin flag
    if [[ "${1:-}" == "-" ]]; then
        if [[ -t 0 ]]; then
            log_error "No input on stdin"
            exit 1
        fi
        prompt=$(cat)
    else
        prompt="${1:-}"
    fi

    if [[ -z "$prompt" ]]; then
        log_error "No prompt provided"
        exit 1
    fi

    local fifo_path
    fifo_path=$(get_fifo_path)

    if [[ ! -p "$fifo_path" ]]; then
        log_error "FIFO not found: $fifo_path"
        log_error "Is master running with AI_SWARM_INTERACTIVE=1?"
        exit 1
    fi

    if ! write_fifo_nonblocking "$fifo_path" "$prompt"; then
        log_error "No reader on FIFO (is master running with AI_SWARM_INTERACTIVE=1?)"
        exit 1
    fi

    log_info "Task written to FIFO: ${prompt:0:50}..."
}

# Main
case "${1:-}" in
    write)
        cmd_write "${2:-}"
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        if [[ -n "${1:-}" ]]; then
            log_error "Unknown command: $1"
        fi
        usage
        exit 1
        ;;
esac
```

Set executable: chmod +x swarm_fifo_write.sh
</action>
  <verify>./scripts/swarm_fifo_write.sh help 2>&1</verify>
  <done>swarm_fifo_write.sh uses Python for O_NONBLOCK write, returns error if no reader</done>
</task>

<task type="auto">
  <name>Write unit tests with proper isolation</name>
  <files>/home/user/projects/AAA/swarm/tests/test_fifo_input.py</files>
  <action>
Create /home/user/projects/AAA/swarm/tests/test_fifo_input.py with PROPER ISOLATION:

```python
#!/usr/bin/env python3
"""
Unit tests for fifo_input.py - FIFO input channel and command parsing

IMPORTANT: Tests must NOT pollute global state. Each test should:
- Not rely on importlib.reload (changes global state)
- Mock environment variables at test time, not module load time
- Use fixtures to reset state between tests
"""

import os
import sys
import stat
import tempfile
import pytest
import threading
import time
from pathlib import Path
from unittest.mock import MagicMock, patch, PropertyMock

# Import functions and class (not module-level env-dependent constants)
from swarm.fifo_input import FifoInputHandler, get_fifo_path, get_interactive_mode


class TestGetFunctions:
    """Test helper functions with proper env isolation"""

    def test_get_fifo_path_default(self):
        """Test FIFO path uses default when AI_SWARM_DIR not set"""
        with patch.dict(os.environ, {}, clear=True):
            path = get_fifo_path()
            assert path == "/tmp/ai_swarm/master_inbox"

    def test_get_fifo_path_custom(self):
        """Test FIFO path respects AI_SWARM_DIR"""
        with patch.dict(os.environ, {"AI_SWARM_DIR": "/custom/path"}):
            path = get_fifo_path()
            assert path == "/custom/path/master_inbox"

    def test_get_interactive_mode_disabled(self):
        """Test interactive mode disabled by default"""
        env = {k: v for k, v in os.environ.items() if k != "AI_SWARM_INTERACTIVE"}
        with patch.dict(os.environ, env, clear=False):
            mode = get_interactive_mode()
            assert mode is False

    def test_get_interactive_mode_enabled(self):
        """Test interactive mode enabled with env var"""
        with patch.dict(os.environ, {"AI_SWARM_INTERACTIVE": "1"}):
            mode = get_interactive_mode()
            assert mode is True


class TestFifoInputHandler:
    """Tests for FifoInputHandler class"""

    @pytest.fixture
    def handler_with_isolated_env(self, tmp_path):
        """Create handler with isolated temp directory for AI_SWARM_DIR"""
        with patch.dict(os.environ, {"AI_SWARM_DIR": str(tmp_path)}):
            handler = FifoInputHandler()
            handler._broadcaster = MagicMock()
            return handler

    def test_parse_command_task_with_prefix(self, handler_with_isolated_env):
        """Test /task command parsing with prompt"""
        cmd, payload = handler_with_isolated_env._parse_command("/task review pr #123")
        assert cmd == "task"
        assert payload == "review pr #123"

    def test_parse_command_task_without_prompt_error(self, handler_with_isolated_env):
        """Test /task without prompt returns error"""
        cmd, payload = handler_with_isolated_env._parse_command("/task")
        assert cmd == "error"
        assert "requires a prompt" in payload

    def test_parse_command_help(self, handler_with_isolated_env):
        """Test /help command parsing"""
        cmd, payload = handler_with_isolated_env._parse_command("/help")
        assert cmd == "help"
        assert payload is None

    def test_parse_command_quit(self, handler_with_isolated_env):
        """Test /quit command parsing"""
        cmd, payload = handler_with_isolated_env._parse_command("/quit")
        assert cmd == "quit"
        assert payload is None

    def test_parse_command_plain_text(self, handler_with_isolated_env):
        """Test plain text treated as task prompt"""
        cmd, payload = handler_with_isolated_env._parse_command("fix the login bug")
        assert cmd == "task"
        assert payload == "fix the login bug"

    def test_parse_command_empty_line(self, handler_with_isolated_env):
        """Test empty line is ignored"""
        cmd, payload = handler_with_isolated_env._parse_command("")
        assert cmd == "ignore"

    def test_parse_command_whitespace_only(self, handler_with_isolated_env):
        """Test whitespace-only line is ignored"""
        cmd, payload = handler_with_isolated_env._parse_command("   \n")
        assert cmd == "ignore"

    def test_parse_command_unknown(self, handler_with_isolated_env):
        """Test unknown command returns error"""
        cmd, payload = handler_with_isolated_env._parse_command("/unknown arg")
        assert cmd == "error"
        assert "Unknown command" in payload

    def test_handle_task_calls_queue(self, handler_with_isolated_env):
        """Test _handle_task calls TaskQueue.add_task"""
        handler_with_isolated_env._task_queue = MagicMock()
        handler_with_isolated_env._task_queue.add_task.return_value = "task_001"

        handler_with_isolated_env._handle_task("test prompt")

        handler_with_isolated_env._task_queue.add_task.assert_called_once_with("test prompt")

    def test_handle_task_empty_skipped(self, handler_with_isolated_env):
        """Test _handle_task skips empty prompt"""
        handler_with_isolated_env._task_queue = MagicMock()
        handler_with_isolated_env._handle_task("")
        handler_with_isolated_env._task_queue.add_task.assert_not_called()

    def test_handle_help_outputs_text(self, handler_with_isolated_env, capsys):
        """Test _handle_help prints help text"""
        handler_with_isolated_env._handle_help()
        captured = capsys.readouterr()
        assert "/task" in captured.out
        assert "/help" in captured.out
        assert "/quit" in captured.out

    def test_shutdown_stops_handler(self, handler_with_isolated_env):
        """Test _shutdown sets running to False"""
        assert handler_with_isolated_env.running is True
        handler_with_isolated_env._shutdown()
        assert handler_with_isolated_env.running is False

    def test_handler_creates_own_queue(self):
        """Test FifoInputHandler creates its own TaskQueue internally"""
        with patch.dict(os.environ, {}, clear=True):
            handler = FifoInputHandler()
            # Should have a TaskQueue instance, not None
            from swarm.task_queue import TaskQueue
            assert isinstance(handler._task_queue, TaskQueue)


class TestFifoCreation:
    """Tests for FIFO creation"""

    def test_ensure_fifo_creates_fifo(self, tmp_path):
        """Test _ensure_fifo_exists creates a FIFO"""
        with patch.dict(os.environ, {"AI_SWARM_DIR": str(tmp_path)}):
            handler = FifoInputHandler()
            # Handler uses get_fifo_path() which respects env
            assert os.path.basename(handler.fifo_path) == "master_inbox"
            handler._ensure_fifo_exists()
            assert stat.S_ISFIFO(os.lstat(handler.fifo_path).st_mode)


class TestBroadcastSignature:
    """Tests for broadcast_start() signature (no worker_id parameter)"""

    def test_broadcast_start_signature_no_worker_id(self):
        """Test broadcast_start is called with task_id and message only"""
        with patch.dict(os.environ, {}, clear=True):
            handler = FifoInputHandler()
            handler._broadcaster = MagicMock()

            handler._handle_task("test prompt")

            # broadcast_start should be called with task_id and message
            # Signature: broadcast_start(task_id, message, meta=None)
            handler._broadcaster.broadcast_start.assert_called_once()
            call_kwargs = handler._broadcaster.broadcast_start.call_kwargs

            # Should have task_id and message
            assert 'task_id' in call_kwargs
            assert 'message' in call_kwargs
            # Should NOT have worker_id
            assert 'worker_id' not in call_kwargs


class TestNonBlockingWrite:
    """Tests for write_to_fifo_nonblocking function"""

    def test_write_to_fifo_nonblocking_success(self, tmp_path):
        """Test successful non-blocking write to FIFO"""
        fifo_path = str(tmp_path / "test_fifo")
        os.mkfifo(fifo_path, mode=0o666)

        # Start a reader in background (to prevent EAGAIN)
        import subprocess
        reader = subprocess.Popen(['cat', fifo_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        try:
            from swarm.fifo_input import write_to_fifo_nonblocking
            result = write_to_fifo_nonblocking(fifo_path, "test message")
            assert result is True
        finally:
            reader.terminate()
            reader.wait()

    def test_write_to_fifo_nonblocking_no_reader(self, tmp_path):
        """Test write returns False when no reader"""
        fifo_path = str(tmp_path / "test_fifo")
        os.mkfifo(fifo_path, mode=0o666)

        from swarm.fifo_input import write_to_fifo_nonblocking
        # No reader, should return False (EAGAIN)
        result = write_to_fifo_nonblocking(fifo_path, "test message")
        assert result is False

    def test_write_to_fifo_nonblocking_nonexistent(self, tmp_path):
        """Test write raises exception when FIFO doesn't exist"""
        fifo_path = str(tmp_path / "nonexistent_fifo")

        from swarm.fifo_input import write_to_fifo_nonblocking
        with pytest.raises(FileNotFoundError):
            write_to_fifo_nonblocking(fifo_path, "test message")


class TestThreadIndependence:
    """Tests for thread independence (Master vs FIFO handler)"""

    def test_quit_only_stops_handler(self):
        """Test /quit only stops FifoInputHandler, not Master"""
        with patch.dict(os.environ, {}, clear=True):
            handler = FifoInputHandler()
            handler._broadcaster = MagicMock()

            # Simulate /quit
            handler.running = True
            handler._shutdown()

            # Only handler.running should be False, not master
            assert handler.running is False
</action>
  <verify>pytest tests/test_fifo_input.py -v --tb=short 2>&1 | tail -60</verify>
  <done>All tests pass: TestGetFunctions, TestFifoInputHandler, TestFifoCreation, TestBroadcastSignature, TestNonBlockingWrite, TestThreadIndependence</done>
</task>

<task type="auto">
  <name>Update documentation for V1.9 FIFO feature</name>
  <files>/home/user/projects/AAA/swarm/README.md, /home/user/projects/AAA/swarm/CHANGELOG.md, /home/user/projects/AAA/swarm/docs/SCRIPTS.md</files>
  <action>
Update documentation files:

1. **CHANGELOG.md** - Add v1.9 entry:
   ```
   ## v1.9 (TBD)

   **New Features:**
   - FIFO 输入通道 - 通过命名管道向 master 发布自然语言任务
   - `AI_SWARM_INTERACTIVE=1` 启用交互模式
   - `swarm task add "<prompt>"` - CLI 命令向 FIFO 写入任务
   - `./scripts/swarm_fifo_write.sh write "<prompt>"` - Bash 辅助脚本
   - `/task`, `/help`, `/quit` 指令解析

   **Changes:**
   - Master 支持后台运行时接收任务输入
   - FifoInputHandler 独立线程，不阻塞主循环

   **Compatibility:**
   - 默认为禁用，不影响现有行为
   - 需要 `AI_SWARM_INTERACTIVE=1` 启用
   ```

2. **README.md** - Add "自然语言发布任务" section:
   ```
   ## 自然语言发布任务

   当 master 在 tmux 后台运行时，可以通过 FIFO 输入通道发布任务：

   ```bash
   # 启用交互模式
   export AI_SWARM_INTERACTIVE=1

   # 启动 master
   python3 -m swarm.cli master --cluster-id default
   ```

   ### 发布任务

   **方式 1: CLI 命令**
   ```bash
   swarm task add "Review PR #123"
   echo "Fix bug" | swarm task add -
   ```

   **方式 2: Bash 脚本**
   ```bash
   ./scripts/swarm_fifo_write.sh write "Review PR #123"
   echo "Task" | ./scripts/swarm_fifo_write.sh write -
   ```

   **方式 3: 直接写入 FIFO**
   ```bash
   echo "Task description" > $AI_SWARM_DIR/master_inbox
   ```

   ### FIFO 指令

   - `/task <prompt>` - 创建任务
   - `/help` - 显示帮助
   - `/quit` - 停止输入线程（master 继续运行）
   - 无前缀文本 - 直接作为任务

   **注意:** 需要 master 运行并设置 `AI_SWARM_INTERACTIVE=1`
   ```

3. **docs/SCRIPTS.md** - Add swarm_fifo_write.sh documentation:
   ```
   ## swarm_fifo_write.sh

   向 master FIFO 输入通道写入任务提示。

   **用法:**
   ```bash
   ./scripts/swarm_fifo_write.sh write "<prompt>"   # 从参数读取
   ./scripts/swarm_fifo_write.sh write -           # 从 stdin 读取
   ./scripts/swarm_fifo_write.sh help               # 显示帮助
   ```

   **环境变量:**
   - `AI_SWARM_DIR` - swarm 状态目录（默认: /tmp/ai_swarm）

   **退出码:**
   - 0: 成功
   - 1: 错误（FIFO 不存在、无输入等）
   ```
</action>
  <verify>echo "Documentation updated. Verify manually:"; grep -l "FIFO" README.md CHANGELOG.md docs/SCRIPTS.md 2>/dev/null | wc -l</verify>
  <done>CHANGELOG.md, README.md, docs/SCRIPTS.md all updated with FIFO feature docs</done>
</task>

</tasks>

<verification>
## Phase 34 Verification

Run these commands to verify all requirements are met:

```bash
# 1. Helper functions work correctly
python3 -c "
from swarm.fifo_input import get_fifo_path, get_interactive_mode
print(f'FIFO path: {get_fifo_path()}')
print(f'Interactive mode: {get_interactive_mode()}')"

# 2. FifoInputHandler creates own TaskQueue
python3 -c "
from swarm.fifo_input import FifoInputHandler
h = FifoInputHandler()
print(f'Has TaskQueue: {hasattr(h, \"_task_queue\")}')
print(f'FIFO path: {h.fifo_path}')"

# 3. /task without prompt shows error
python3 -c "
from swarm.fifo_input import FifoInputHandler
h = FifoInputHandler()
cmd, payload = h._parse_command('/task')
print(f'cmd={cmd}, payload={payload}')"

# 4. CLI help
python3 -m swarm.cli task add --help

# 5. Bash script help
./scripts/swarm_fifo_write.sh help

# 6. All unit tests pass
pytest tests/test_fifo_input.py -v

# 7. Documentation exists
grep -q "FIFO" README.md && echo "README OK"
grep -q "FIFO" CHANGELOG.md && echo "CHANGELOG OK"
grep -q "swarm_fifo_write" docs/SCRIPTS.md && echo "SCRIPTS OK"
```

Expected results:
- get_fifo_path() returns "$AI_SWARM_DIR/master_inbox"
- get_interactive_mode() returns boolean
- /task without prompt returns error
- All pytest tests pass
- Documentation files updated
</verification>

<success_criteria>
## Phase 34 Success Criteria (FIXED)

- [x] FifoInputHandler creates own TaskQueue internally (not passed from Master)
- [x] FIFO non-blocking read with os.open() O_NONBLOCK + select.poll()
- [x] /task without prompt shows error, no empty tasks created
- [x] get_fifo_path() and get_interactive_mode() functions for dynamic config
- [x] /quit only stops FifoInputHandler, Master continues
- [x] `swarm task add` writes to FIFO, supports `-` for stdin
- [x] swarm_fifo_write.sh works with stdin support
- [x] Tests have proper isolation (no importlib.reload pollution)
- [x] Documentation updated (README.md, CHANGELOG.md, docs/SCRIPTS.md)
- [x] All unit tests pass (pytest tests/test_fifo_input.py)
</success_criteria>

<output>
After completion, create `.planning/phases/34-fifo-input-command-parsing/34-01-SUMMARY.md`
</output>
