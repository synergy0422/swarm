---
phase: 19-任务流程闭环
plan: 19-01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/swarm_task_wrap.sh
autonomous: true
user_setup: []

must_haves:
  truths:
    - "swarm_task_wrap.sh wraps task execution with lock/state lifecycle"
    - "Flow: acquire lock → write START → execute → write DONE/ERROR → release"
    - "Acquire failure writes SKIP/WAIT status (not START)"
    - "Only releases locks this script acquired (owner validation)"
    - "Status writes use swarm_status_log.sh append"
    - "Lock operations use swarm_lock.sh acquire/release"
  artifacts:
    - path: "scripts/swarm_task_wrap.sh"
      provides: "Task lifecycle wrapper with lock/state integration"
      min_lines: 80
  key_links:
    - from: "scripts/swarm_task_wrap.sh"
      to: "scripts/swarm_lock.sh"
      via: "acquire/release commands for task locking"
      pattern: "swarm_lock\\.sh (acquire|release)"
    - from: "scripts/swarm_task_wrap.sh"
      to: "scripts/swarm_status_log.sh"
      via: "append command for status updates"
      pattern: "swarm_status_log\\.sh append"
    - from: "scripts/swarm_task_wrap.sh"
      to: "scripts/_common.sh"
      via: "source statement for config and logging"
      pattern: "source.*_common\\.sh"
---

<objective>
Create `scripts/swarm_task_wrap.sh` that wraps task execution with complete lock and state lifecycle management.

Purpose: This script provides a standardized way to execute tasks with proper lock acquisition, status broadcasting, and cleanup. It ensures tasks are tracked through their lifecycle (START → DONE/ERROR) and that locks are properly managed.

Output: `scripts/swarm_task_wrap.sh` - an executable bash script for wrapped task execution
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/user/projects/AAA/swarm/.planning/ROADMAP.md
@/home/user/projects/AAA/swarm/.planning/REQUIREMENTS.md

# Phase 18 foundation (must use)
@/home/user/projects/AAA/swarm/scripts/_config.sh
@/home/user/projects/AAA/swarm/scripts/_common.sh

# Existing scripts to integrate with
@/home/user/projects/AAA/swarm/scripts/swarm_lock.sh
@/home/user/projects/AAA/swarm/scripts/swarm_status_log.sh

# Key interfaces from existing scripts:
# - swarm_lock.sh: acquire <task_id> <worker> [ttl], release <task_id> <worker>
# - swarm_status_log.sh: append <type> <worker> <task_id> [reason]
# - Valid types: START, DONE, ERROR, WAIT, HELP, SKIP
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scripts/swarm_task_wrap.sh with full lifecycle wrapper</name>
  <files>scripts/swarm_task_wrap.sh</files>
  <action>
Create `scripts/swarm_task_wrap.sh` with proper argument parsing and lifecycle management:

1. **Boilerplate and sourcing**:
   ```bash
   #!/usr/bin/env bash
   set -euo pipefail

   SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
   source "$SCRIPT_DIR/_common.sh"
   ```

2. **Global state for trap callbacks** (must be declared before functions):
   ```bash
   # Global state for lifecycle management
   LOCK_ACQUIRED=0
   LOCK_TASK_ID=""
   LOCK_WORKER=""
   SKIP_STATUS=0
   ```

3. **Usage function**:
   ```bash
   usage() {
       cat <<EOF
   Usage: $(basename "$0") <command> [arguments]

   Commands:
       run <task_id> <worker> <command> [args...]
           Execute a command with full task lifecycle (lock + status)

       acquire-only <task_id> [worker]
           Acquire lock and write START status (for manual execution)
           Worker defaults to auto-detection if not provided

       release-only <task_id> [worker]
           Release lock and write DONE status (for completed tasks)
           Worker defaults to auto-detection if not provided

       skip <task_id> [worker] <reason>
           Write SKIP status (no lock operation - for tasks not yet started)

       wait <task_id> [worker] <reason>
           Write WAIT status (no lock operation - for blocked tasks)

   Options:
       --ttl SECONDS    Lock TTL in seconds (default: no expiry)
       --no-status      Skip status logging (for testing)

   Environment:
       SWARM_STATE_DIR  Override state directory (default: from _config.sh)
       WORKER           Worker name for auto-detection

   Examples:
       $(basename "$0") run task-001 worker-0 "python process.py"
       $(basename "$0") run --ttl 3600 task-002 worker-1 "./script.sh arg1"
       $(basename "$0") skip task-003 "Dependency not ready"
       $(basename "$0") wait task-004 "Waiting for upstream"
   EOF
   }
   ```

4. **Helper function to detect worker**:
   ```bash
   detect_worker() {
       if [[ -n "$WORKER" ]]; then
           echo "$WORKER"
           return 0
       fi
       # Fallback to default from config
       echo "${WORKER:-worker-0}"
   }
   ```

5. **Cleanup functions** (must access global state):
   ```bash
   cleanup_on_error() {
       local exit_code=$1
       if [[ "$LOCK_ACQUIRED" -eq 1 ]]; then
           log_warn "Cleaning up after error for $LOCK_TASK_ID"
           "$SCRIPT_DIR/swarm_status_log.sh" append ERROR "$LOCK_WORKER" "$LOCK_TASK_ID" "Error during execution: exit $exit_code"
           "$SCRIPT_DIR/swarm_lock.sh" release "$LOCK_TASK_ID" "$LOCK_WORKER" 2>/dev/null || true
       fi
   }

   cleanup_done() {
       if [[ "$LOCK_ACQUIRED" -eq 1 ]]; then
           "$SCRIPT_DIR/swarm_lock.sh" release "$LOCK_TASK_ID" "$LOCK_WORKER" 2>/dev/null || true
       fi
   }
   ```

6. **Option parsing function** (parses --ttl, --no-status before positional args):
   ```bash
   parse_options() {
       TTL_SECONDS=""
       SKIP_STATUS=0

       while [[ $# -gt 0 ]]; do
           case "$1" in
               --ttl)
                   TTL_SECONDS="$2"
                   shift 2
                   ;;
               --no-status)
                   SKIP_STATUS=1
                   shift
                   ;;
               *)
                   # Not an option, stop parsing
                   break
                   ;;
           esac
       done
   }
   ```

7. **Helper commands** with proper worker parameter handling:
   ```bash
   cmd_acquire_only() {
       local task_id="$1"
       local worker="${2:-$(detect_worker)}"

       if ! "$SCRIPT_DIR/swarm_lock.sh" acquire "$task_id" "$worker" "${TTL_SECONDS:-}"; then
           log_error "Failed to acquire lock for $task_id"
           [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append WAIT "$worker" "$task_id" "Lock not acquired"
           exit 1
       fi
       [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append START "$worker" "$task_id" ""
       log_info "Acquired lock and started $task_id"
   }

   cmd_release_only() {
       local task_id="$1"
       local worker="${2:-$(detect_worker)}"

       "$SCRIPT_DIR/swarm_lock.sh" release "$task_id" "$worker"
       [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append DONE "$worker" "$task_id" "Completed"
       log_info "Released lock for $task_id"
   }

   cmd_skip() {
       local task_id="$1"
       local worker="${2:-$(detect_worker)}"
       local reason="$3"

       # skip does NOT acquire/release lock - just write status
       [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append SKIP "$worker" "$task_id" "$reason"
       log_info "Skipped $task_id: $reason"
   }

   cmd_wait() {
       local task_id="$1"
       local worker="${2:-$(detect_worker)}"
       local reason="$3"

       # wait does NOT acquire/release lock - just write status
       [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append WAIT "$worker" "$task_id" "$reason"
       log_info "Set $task_id to wait: $reason"
   }
   ```

8. **Core function: cmd_run** - proper option parsing, no eval:
   ```bash
   cmd_run() {
       # Parse options first
       parse_options "$@"
       shift $((OPTIND - 1))

       # Now parse positional arguments
       if [[ $# -lt 3 ]]; then
           log_error "run requires: <task_id> <worker> <command> [args...]"
           exit 1
       fi

       local task_id="$1"
       local worker="$2"
       shift 2

       # Remaining args are the command to execute
       local cmd_args=("$@")

       # Set global state for trap callbacks
       LOCK_ACQUIRED=0
       LOCK_TASK_ID="$task_id"
       LOCK_WORKER="$worker"

       # Step 1: Acquire lock
       if ! "$SCRIPT_DIR/swarm_lock.sh" acquire "$task_id" "$worker" "${TTL_SECONDS:-}"; then
           log_warn "Failed to acquire lock for $task_id"
           # Step 1a: Write WAIT status (lock held by another)
           [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append WAIT "$worker" "$task_id" "Lock not acquired"
           exit 1
       fi
       LOCK_ACQUIRED=1

       # Step 2: Write START status
       [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append START "$worker" "$task_id" ""
       log_info "Started task $task_id on $worker"

       # Step 3: Execute command with cleanup traps (NO eval!)
       trap 'cleanup_on_error $?' ERR
       trap 'cleanup_done' EXIT

       set +e
       "${cmd_args[@]}"  # Execute command directly, no eval
       local exit_code=$?
       set -e

       # Step 4: Write DONE or ERROR based on exit code
       if [[ $exit_code -eq 0 ]]; then
           [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append DONE "$worker" "$task_id" "Completed successfully"
           log_info "Task $task_id completed"
       else
           [[ "$SKIP_STATUS" -eq 0 ]] && "$SCRIPT_DIR/swarm_status_log.sh" append ERROR "$worker" "$task_id" "Exit code: $exit_code"
           log_error "Task $task_id failed with exit code $exit_code"
           exit $exit_code
       fi
   }
   ```

9. **Main entry point**:
   ```bash
   main() {
       if [[ $# -lt 1 ]]; then
           usage
           exit 1
       fi

       local cmd="$1"
       shift

       case "$cmd" in
           help|h|--help|-h)
               usage
               ;;
           run)
               cmd_run "$@"
               ;;
           acquire-only|acquire)
               cmd_acquire_only "$@"
               ;;
           release-only|release)
               cmd_release_only "$@"
               ;;
           skip)
               cmd_skip "$@"
               ;;
           wait)
               cmd_wait "$@"
               ;;
           *)
               log_error "Unknown command: $cmd"
               usage
               exit 1
               ;;
       esac
   }

   main "$@"
   ```

**Key fixes applied:**
1. **Argument parsing**: Options (--ttl, --no-status) parsed first via `parse_options()`
2. **No eval**: Command executed via `"${cmd_args[@]}"` instead of `eval "$command"`
3. **Global state**: `LOCK_ACQUIRED`, `LOCK_TASK_ID`, `LOCK_WORKER` declared as globals for trap access
4. **No parameter duplication**: `worker="${2:-$(detect_worker)}"` - single definition with fallback
5. **Consistent WAIT/SKIP**: skip/wait don't acquire/release locks, only write status
6. **No --session**: Removed unnecessary tmux session option
7. **Tests use temp dir**: See Task 2 verification section for isolated test setup

**DO NOT** use eval for command execution
**DO** use global variables for trap callback state
**DO** parse options before positional arguments
**DO** skip lock operations for skip/wait commands (no lock to release if acquire failed)
</action>
  <verify>
# Verify file exists and is executable
test -x scripts/swarm_task_wrap.sh && echo "PASS: Script exists and is executable"

# Verify help output
./scripts/swarm_task_wrap.sh help 2>&1 | grep -q "Usage:" && echo "PASS: Help works"

# Verify required functions exist
grep -q "cmd_run" scripts/swarm_task_wrap.sh && echo "PASS: cmd_run exists"
grep -q "cmd_skip" scripts/swarm_task_wrap.sh && echo "PASS: cmd_skip exists"
grep -q "cmd_wait" scripts/swarm_task_wrap.sh && echo "PASS: cmd_wait exists"
grep -q "cleanup_on_error" scripts/swarm_task_wrap.sh && echo "PASS: Cleanup functions exist"

# Verify it sources _common.sh
grep -q "source.*_common\\.sh" scripts/swarm_task_wrap.sh && echo "PASS: Sources _common.sh"

# Verify it uses swarm_lock.sh
grep -q "swarm_lock\\.sh" scripts/swarm_task_wrap.sh && echo "PASS: Uses swarm_lock.sh"

# Verify it uses swarm_status_log.sh
grep -q "swarm_status_log\\.sh" scripts/swarm_task_wrap.sh && echo "PASS: Uses swarm_status_log.sh"
</verify>
  <done>scripts/swarm_task_wrap.sh exists (80+ lines), is executable, sources _common.sh, and integrates with swarm_lock.sh and swarm_status_log.sh for full task lifecycle management</done>
</task>

<task type="auto">
  <name>Task 2: Test swarm_task_wrap.sh integration with lock and status scripts</name>
  <files>scripts/swarm_task_wrap.sh</files>
  <action>
Test the integration with actual lock and status operations (using isolated temp directory):

1. **Setup isolated test environment**:
   ```bash
   # Create temp directory for test isolation
   TEST_STATE_DIR=$(mktemp -d)
   export SWARM_STATE_DIR="$TEST_STATE_DIR"
   mkdir -p "$TEST_STATE_DIR/locks"
   touch "$TEST_STATE_DIR/status.log"
   ```

2. **Test help and basic parsing**:
   ```bash
   ./scripts/swarm_task_wrap.sh help | head -20
   # Verify help displays correctly
   ```

3. **Test acquire-only flow**:
   ```bash
   # Acquire a test lock
   ./scripts/swarm_task_wrap.sh acquire-only test-wrap-001 worker-0
   # Verify: lock file exists, START status logged
   ls -la "$SWARM_STATE_DIR/locks/test-wrap-001.lock" 2>/dev/null && echo "Lock created"
   ./scripts/swarm_status_log.sh query test-wrap-001 | grep -q "START" && echo "START logged"

   # Release it
   ./scripts/swarm_task_wrap.sh release-only test-wrap-001 worker-0
   # Verify: lock file gone, DONE status logged
   ls "$SWARM_STATE_DIR/locks/test-wrap-001.lock" 2>/dev/null || echo "Lock released"
   ./scripts/swarm_status_log.sh query test-wrap-001 | grep -q "DONE" && echo "DONE logged"
   ```

4. **Test skip flow**:
   ```bash
   ./scripts/swarm_task_wrap.sh skip test-wrap-002 worker-0 "Testing skip"
   # Verify: SKIP status logged (no lock operation)
   ./scripts/swarm_status_log.sh query test-wrap-002 | grep -q "SKIP" && echo "SKIP logged"
   grep -q "Testing skip" <(./scripts/swarm_status_log.sh query test-wrap-002) && echo "Reason preserved"
   ```

5. **Test wait flow**:
   ```bash
   ./scripts/swarm_task_wrap.sh wait test-wrap-003 worker-0 "Testing wait"
   # Verify: WAIT status logged (no lock operation)
   ./scripts/swarm_status_log.sh query test-wrap-003 | grep -q "WAIT" && echo "WAIT logged"
   ```

6. **Test run flow with successful command**:
   ```bash
   ./scripts/swarm_task_wrap.sh run test-wrap-004 worker-0 "echo 'hello'"
   # Verify: START logged, DONE logged, lock released
   ./scripts/swarm_status_log.sh query test-wrap-004 | grep "START" && echo "START logged"
   ./scripts/swarm_status_log.sh query test-wrap-004 | grep "DONE" && echo "DONE logged"
   ls "$SWARM_STATE_DIR/locks/test-wrap-004.lock" 2>/dev/null || echo "Lock released"
   ```

7. **Test run flow with failing command**:
   ```bash
   ./scripts/swarm_task_wrap.sh run test-wrap-005 worker-0 "exit 1" 2>/dev/null || true
   # Verify: START logged, ERROR logged, lock released
   ./scripts/swarm_status_log.sh query test-wrap-005 | grep "START" && echo "START logged"
   ./scripts/swarm_status_log.sh query test-wrap-005 | grep "ERROR" && echo "ERROR logged"
   ls "$SWARM_STATE_DIR/locks/test-wrap-005.lock" 2>/dev/null || echo "Lock released on error"
   ```

8. **Test acquire failure handling**:
   ```bash
   # First, acquire a lock manually
   ./scripts/swarm_lock.sh acquire test-wrap-006 worker-1
   # Now try to acquire via wrap (should fail and write WAIT, no lock release)
   ./scripts/swarm_task_wrap.sh acquire-only test-wrap-006 worker-1 2>/dev/null || true
   ./scripts/swarm_status_log.sh query test-wrap-006 | grep "WAIT" && echo "WAIT on acquire failure"
   # Cleanup
   ./scripts/swarm_lock.sh release test-wrap-006 worker-1
   ```

9. **Test TTL option**:
   ```bash
   ./scripts/swarm_task_wrap.sh --ttl 60 acquire-only test-wrap-007 worker-0
   # Verify: lock has expiry
   cat "$SWARM_STATE_DIR/locks/test-wrap-007.lock" | grep -q "expires_at" && echo "TTL set"
   # Cleanup
   ./scripts/swarm_task_wrap.sh release-only test-wrap-007 worker-0
   ```

10. **Test --no-status flag**:
    ```bash
    ./scripts/swarm_task_wrap.sh --no-status run test-wrap-008 worker-0 "echo test"
    # Verify: command ran but no status logged
    ./scripts/swarm_status_log.sh query test-wrap-008 | grep -q "No records" && echo "No status logged"
    ```

11. **Cleanup**:
    ```bash
    rm -rf "$TEST_STATE_DIR"
    ```

All tests should pass. If any fail, fix the implementation.
</action>
  <verify>
cd /home/user/projects/AAA/swarm

# Create isolated test environment
TEST_STATE_DIR=$(mktemp -d)
export SWARM_STATE_DIR="$TEST_STATE_DIR"
mkdir -p "$TEST_STATE_DIR/locks"
touch "$TEST_STATE_DIR/status.log"

echo "=== Testing swarm_task_wrap.sh (isolated in $TEST_STATE_DIR) ==="

# Test 1: Help works
./scripts/swarm_task_wrap.sh help >/dev/null 2>&1 && echo "PASS: Help works"

# Test 2: Acquire-only and release-only
./scripts/swarm_task_wrap.sh acquire-only test-wrap-001 worker-0 >/dev/null 2>&1
test -f "$SWARM_STATE_DIR/locks/test-wrap-001.lock" && echo "PASS: Lock created"
./scripts/swarm_status_log.sh query test-wrap-001 2>/dev/null | grep -q "START" && echo "PASS: START logged"

./scripts/swarm_task_wrap.sh release-only test-wrap-001 worker-0 >/dev/null 2>&1
! test -f "$SWARM_STATE_DIR/locks/test-wrap-001.lock" && echo "PASS: Lock released"
./scripts/swarm_status_log.sh query test-wrap-001 2>/dev/null | grep -q "DONE" && echo "PASS: DONE logged"

# Test 3: Skip (no lock operation)
./scripts/swarm_task_wrap.sh skip test-wrap-002 worker-0 "Test skip" >/dev/null 2>&1
./scripts/swarm_status_log.sh query test-wrap-002 2>/dev/null | grep -q "SKIP" && echo "PASS: SKIP logged"

# Test 4: Wait (no lock operation)
./scripts/swarm_task_wrap.sh wait test-wrap-003 worker-0 "Test wait" >/dev/null 2>&1
./scripts/swarm_status_log.sh query test-wrap-003 2>/dev/null | grep -q "WAIT" && echo "PASS: WAIT logged"

# Test 5: Run success
./scripts/swarm_task_wrap.sh run test-wrap-004 worker-0 "echo hello" >/dev/null 2>&1
./scripts/swarm_status_log.sh query test-wrap-004 2>/dev/null | grep -q "START" && echo "PASS: START on run"
./scripts/swarm_status_log.sh query test-wrap-004 2>/dev/null | grep -q "DONE" && echo "PASS: DONE on run"

# Test 6: Run failure
./scripts/swarm_task_wrap.sh run test-wrap-005 worker-0 "exit 1" >/dev/null 2>&1 || true
./scripts/swarm_status_log.sh query test-wrap-005 2>/dev/null | grep -q "ERROR" && echo "PASS: ERROR on failure"

# Test 7: Acquire failure writes WAIT (no lock to release)
./scripts/swarm_lock.sh acquire test-wrap-006 worker-1 >/dev/null 2>&1
./scripts/swarm_task_wrap.sh acquire-only test-wrap-006 worker-1 >/dev/null 2>&1 || true
./scripts/swarm_status_log.sh query test-wrap-006 2>/dev/null | grep -q "WAIT" && echo "PASS: WAIT on acquire failure"
./scripts/swarm_lock.sh release test-wrap-006 worker-1 >/dev/null 2>&1

# Cleanup - remove isolated test dir
rm -rf "$TEST_STATE_DIR"

echo "=== All integration tests completed ==="
</verify>
  <done>All 7 integration tests pass: acquire-only, release-only, skip, wait, run success, run failure, acquire failure handling</done>
</task>

<task type="auto">
  <name>Task 3: Verify lock release ownership validation</name>
  <files>scripts/swarm_task_wrap.sh</files>
  <action>
Verify that the script only releases locks that it acquired (owner validation):

1. **Test that different worker cannot release**:
   ```bash
   # Worker-0 acquires lock
   ./scripts/swarm_task_wrap.sh acquire-only test-owner-001 worker-0

   # Try to release with worker-1 (should fail per swarm_lock.sh validation)
   ./scripts/swarm_task_wrap.sh release-only test-owner-001 worker-1 2>&1 | grep -q "Error" && echo "PASS: Owner validation works"
   # Or verify lock still exists (release failed)
   test -f /tmp/ai_swarm/locks/test-owner-001.lock && echo "PASS: Lock not released by wrong worker"

   # Correct worker releases
   ./scripts/swarm_task_wrap.sh release-only test-owner-001 worker-0
   ```

2. **Test skip/wait don't release locks** (they don't acquire, so nothing to release):
   ```bash
   # skip doesn't acquire lock, just writes status
   ./scripts/swarm_task_wrap.sh skip test-owner-002 worker-0 "Testing skip"
   # Verify: SKIP logged, no lock file created
   test -f /tmp/ai_swarm/locks/test-owner-002.lock && echo "FAIL: Lock should not exist" || echo "PASS: No lock for skip"

   # wait doesn't acquire lock, just writes status
   ./scripts/swarm_task_wrap.sh wait test-owner-003 worker-0 "Testing wait"
   # Verify: WAIT logged, no lock file created
   test -f /tmp/ai_swarm/locks/test-owner-003.lock && echo "FAIL: Lock should not exist" || echo "PASS: No lock for wait"
   ```

3. **Test that cleanup trap releases only acquired lock**:
   ```bash
   # Start a task that will fail mid-execution
   cat > /tmp/test_fail.sh << 'EOF'
   #!/bin/bash
   source /home/user/projects/AAA/swarm/scripts/_common.sh
   # Simulate a task that fails
   ./scripts/swarm_task_wrap.sh run test-owner-004 worker-0 "exit 1" 2>/dev/null || true
   # Check lock state
   if [ -f /tmp/ai_swarm/locks/test-owner-004.lock ]; then
       echo "FAIL: Lock still exists after failed task"
   else
       echo "PASS: Lock released after failed task"
   fi
   EOF
   chmod +x /tmp/test_fail.sh
   /tmp/test_fail.sh
   ```

4. **Verify lock files have worker metadata**:
   ```bash
   # Acquire a lock
   ./scripts/swarm_task_wrap.sh acquire-only test-owner-005 worker-2

   # Check the lock file contains worker info
   cat /tmp/ai_swarm/locks/test-owner-005.lock | grep -q "worker" && echo "PASS: Lock has worker metadata"

   # Cleanup
   ./scripts/swarm_task_wrap.sh release-only test-owner-005 worker-2
   ```

All tests should pass. The key requirement is that swarm_lock.sh release command validates ownership (this is already implemented in swarm_lock.sh).
</action>
  <verify>
cd /home/user/projects/AAA/swarm

# Create isolated test environment
TEST_STATE_DIR=$(mktemp -d)
export SWARM_STATE_DIR="$TEST_STATE_DIR"
mkdir -p "$TEST_STATE_DIR/locks"
touch "$TEST_STATE_DIR/status.log"

echo "=== Testing lock ownership validation (isolated) ==="

# Test 1: Wrong worker cannot release
./scripts/swarm_task_wrap.sh acquire-only test-owner-001 worker-0 >/dev/null 2>&1
./scripts/swarm_task_wrap.sh release-only test-owner-001 worker-1 >/dev/null 2>&1 || true
if test -f "$TEST_STATE_DIR/locks/test-owner-001.lock"; then
    echo "PASS: Lock not released by wrong worker"
    ./scripts/swarm_task_wrap.sh release-only test-owner-001 worker-0 >/dev/null 2>&1
else
    echo "INFO: Lock was released (check swarm_lock.sh owner validation)"
fi

# Test 2: Correct worker can release
./scripts/swarm_task_wrap.sh acquire-only test-owner-002 worker-1 >/dev/null 2>&1
! test -f "$TEST_STATE_DIR/locks/test-owner-002.lock" && echo "PASS: Lock released by owner" || echo "FAIL: Lock not released"

# Test 3: Failed task cleanup
./scripts/swarm_task_wrap.sh run test-owner-003 worker-0 "exit 42" >/dev/null 2>&1 || true
! test -f "$TEST_STATE_DIR/locks/test-owner-003.lock" && echo "PASS: Lock released after failure" || echo "FAIL: Lock not released"

# Cleanup - remove isolated test dir
rm -rf "$TEST_STATE_DIR"

echo "=== Ownership validation tests complete ==="
</verify>
  <done>Lock ownership validation works: wrong worker cannot release locks, acquired locks are released on success/error, cleanup properly handles lock release</done>
</task>

</tasks>

<verification>
## Script Verification

```bash
# Basic file checks
test -x scripts/swarm_task_wrap.sh && echo "PASS: Script exists and is executable"

# Help verification
./scripts/swarm_task_wrap.sh help | head -10

# Integration verification (all should PASS)
# See Task 2 verification section

# Ownership verification (all should PASS)
# See Task 3 verification section
```

## Failure Scenario Tests

```bash
# Test 1: Acquire failure (lock held by another)
# Terminal 1:
./scripts/swarm_lock.sh acquire held-task worker-0

# Terminal 2:
./scripts/swarm_task_wrap.sh run held-task worker-0 "echo test"
# Expected: WAIT status written, exit 1

# Test 2: Command failure
./scripts/swarm_task_wrap.sh run fail-task worker-0 "exit 1"
# Expected: START logged, ERROR logged, lock released

# Test 3: Script interruption
./scripts/swarm_task_wrap.sh run interrupt-task worker-0 "sleep 100" &
PID=$!
sleep 1
kill $PID 2>/dev/null || true
wait $PID 2>/dev/null || true
# Expected: Lock released after SIGTERM (via trap)
```

## Status Log Verification

```bash
# View all test entries
./scripts/swarm_status_log.sh tail 20

# Query specific task lifecycle
./scripts/swarm_task_wrap.sh run lifecycle-test worker-0 "echo done"
./scripts/swarm_status_log.sh query lifecycle-test

# Expected output for successful run:
# {"timestamp":"...","type":"START","worker":"worker-0","task_id":"lifecycle-test"}
# {"timestamp":"...","type":"DONE","worker":"worker-0","task_id":"lifecycle-test"}
```
</verification>

<success_criteria>
1. `scripts/swarm_task_wrap.sh` exists and is executable (chmod +x)
2. Script sources `_common.sh` for configuration and logging
3. Commands implemented: `run`, `acquire-only`, `release-only`, `skip`, `wait`
4. Full lifecycle flow works: acquire → START → execute → DONE/ERROR → release
5. Failure handling: acquire fails → WAIT status, execute fails → ERROR status
6. Lock release validates ownership (only releases locks this script acquired)
7. Status writes use `swarm_status_log.sh append`
8. Lock operations use `swarm_lock.sh acquire/release`
9. Supports options: `--ttl`, `--no-status`, `--worker`
10. All integration tests pass (help, acquire-only, release-only, skip, wait, run success, run failure, acquire failure)
</success_criteria>

<output>
After completion, create `.planning/phases/19-任务流程闭环/19-01-SUMMARY.md`
</output>
