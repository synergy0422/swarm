---
phase: 29-task-assignment闭环
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified: ["swarm/master_dispatcher.py", "swarm/master.py"]
autonomous: true
user_setup: []
gap_closure: false

must_haves:
  truths:
    - "dispatch_one() broadcasts ASSIGNED state when task assigned to worker"
    - "ASSIGNED appears in status.log with pure ASSIGNED state (no meta.event)"
    - "State chain shows: ASSIGNED (from master) → START (from worker) → DONE/ERROR (from worker)"
    - "Status summary shows ASSIGNED in priority ordering"
  artifacts:
    - path: "swarm/master_dispatcher.py"
      provides: "dispatch_one() broadcasts BroadcastState.ASSIGNED"
      contains: "BroadcastState.ASSIGNED"
      min_lines: 10
    - path: "swarm/master.py"
      provides: "STATE_PRIORITY includes ASSIGNED"
      contains: "'ASSIGNED'"
      min_lines: 10
  key_links:
    - from: MasterDispatcher.dispatch_one()
      to: status_broadcaster.BroadcastState.ASSIGNED
      via: Pure ASSIGNED state broadcast
    - from: STATUS_PRIORITY
      to: Master.summary()
      via: ASSIGNED state ordering in summary
---

<objective>
Fix task assignment state chain: Master should broadcast ASSIGNED state when dispatching tasks, creating clear state progression: ASSIGNED → START → DONE/ERROR.

Currently dispatch_one() broadcasts START with meta.event='ASSIGNED' which is semantically wrong and confuses status tracking.
</objective>

<execution_context>
@/home/user/projects/AAA/swarm/swarm/master_dispatcher.py
@/home/user/projects/AAA/swarm/swarm/master.py
@/home/user/projects/AAA/swarm/swarm/status_broadcaster.py
</execution_context>

<context>
## Problem Statement

Current implementation (INCORRECT):
```python
# master_dispatcher.py dispatch_one() line 302
self._broadcaster._broadcast(
    state=status_broadcaster.BroadcastState.START,  # WRONG!
    task_id=task.task_id,
    message=f'Task assigned to {worker_id}',
    meta={
        'assigned_worker_id': worker_id,
        'event': 'ASSIGNED'  # Trying to fake ASSIGNED via meta
    }
)
```

This creates confusing status.log entries:
```
{"state": "START", "meta": {"event": "ASSIGNED", ...}}
```

## Correct Behavior

Master dispatcher should broadcast pure ASSIGNED state:
```python
self._broadcaster._broadcast(
    state=status_broadcaster.BroadcastState.ASSIGNED,
    task_id=task.task_id,
    message=f'Task assigned to {worker_id}',
    meta={'assigned_worker_id': worker_id}
)
```

Resulting status.log:
```
{"state": "ASSIGNED", "meta": {"assigned_worker_id": "worker-1"}}
```

## State Chain After Fix

1. **ASSIGNED** - Master broadcasts when task assigned to worker
2. **START** - Worker broadcasts when beginning execution
3. **DONE/ERROR** - Worker broadcasts when completing

## Files to Modify

1. **swarm/master_dispatcher.py** - Change dispatch_one() to use ASSIGNED state
2. **swarm/master.py** - Add ASSIGNED to STATE_PRIORITY (between START and DONE)
</context>

<tasks>

<task type="auto">
  <name>Change dispatch_one() to broadcast ASSIGNED state</name>
  <files>swarm/master_dispatcher.py</files>
  <action>
Read swarm/master_dispatcher.py and locate the dispatch_one() method.

Find the _broadcaster._broadcast() call that currently uses BroadcastState.START (around line 270-280).

Change the broadcast to use BroadcastState.ASSIGNED:

```python
# BEFORE (WRONG):
self._broadcaster._broadcast(
    state=status_broadcaster.BroadcastState.START,
    task_id=task.task_id,
    message=f'Task assigned to {worker_id}',
    meta={
        'assigned_worker_id': worker_id,
        'event': 'ASSIGNED'
    }
)

# AFTER (CORRECT):
self._broadcaster._broadcast(
    state=status_broadcaster.BroadcastState.ASSIGNED,
    task_id=task.task_id,
    message=f'Task assigned to {worker_id}',
    meta={
        'assigned_worker_id': worker_id
    }
)
```

Note: Keep the meta['assigned_worker_id'] for tracking which worker was assigned.
</action>
  <verify>python3 -c "
import sys
sys.path.insert(0, 'swarm')
from master_dispatcher import MasterDispatcher
import inspect

source = inspect.getsource(MasterDispatcher.dispatch_one)
# Verify ASSIGNED is used
assert 'BroadcastState.ASSIGNED' in source, 'Missing BroadcastState.ASSIGNED'
# Verify START with event=ASSIGNED is removed
assert \"'event': 'ASSIGNED'\" not in source, 'Still using event=ASSIGNED meta'
# Verify assigned_worker_id meta is kept
assert \"'assigned_worker_id'\" in source, 'Missing assigned_worker_id in meta'
print('dispatch_one() fix verified: OK')
"</verify>
  <done>dispatch_one() broadcasts ASSIGNED state when assigning tasks</done>
</task>

<task type="auto">
  <name>Add ASSIGNED to STATE_PRIORITY</name>
  <files>swarm/master.py</files>
  <action>
Read swarm/master.py and locate STATE_PRIORITY dictionary (around lines 54-61).

Add ASSIGNED to STATE_PRIORITY between START and DONE:

```python
# BEFORE:
STATE_PRIORITY = {
    'ERROR': 0,
    'WAIT': 1,
    'RUNNING': 2,
    'START': 3,
    'DONE': 4,
    'SKIP': 5,
}

# AFTER:
STATE_PRIORITY = {
    'ERROR': 0,
    'WAIT': 1,
    'RUNNING': 2,
    'START': 3,
    'ASSIGNED': 4,  # Add ASSIGNED - shows tasks that are assigned but not yet started
    'DONE': 5,
    'SKIP': 6,
}
```

This ensures ASSIGNED tasks appear in status summary with appropriate priority.
</action>
  <verify>python3 -c "
import sys
sys.path.insert(0, 'swarm')
from master import Master
import inspect

source = inspect.getsource(Master)
assert \"'ASSIGNED': 4\" in source, 'Missing ASSIGNED in STATE_PRIORITY'
print('STATE_PRIORITY includes ASSIGNED: OK')
"</verify>
  <done>ASSIGNED state has priority in status summary ordering</done>
</task>

<task type="auto">
  <name>Add test for ASSIGNED state broadcast</name>
  <files>tests/test_master_dispatcher.py</files>
  <action>
Read tests/test_master_dispatcher.py to understand testing patterns.

Add a test function that verifies dispatch_one() broadcasts ASSIGNED state:

```python
def test_dispatch_one_broadcasts_assigned():
    \"\"\"Test that dispatch_one() broadcasts ASSIGNED state, not START.\"\"\"
    # Setup mock broadcaster
    mock_broadcaster = MagicMock()
    dispatcher = create_test_dispatcher(broadcaster=mock_broadcaster)

    # Create a test task
    task = TaskInfo(task_id='test-task-001', task_type='test', ...)

    # Dispatch the task
    result = dispatcher.dispatch_one(task, 'worker-1')

    # Verify dispatch returned success
    assert result == True

    # Verify ASSIGNED state was broadcast (not START)
    call_args = mock_broadcaster._broadcast.call_args
    assert call_args.kwargs['state'] == BroadcastState.ASSIGNED
    assert call_args.kwargs['task_id'] == 'test-task-001'
    assert 'assigned_worker_id' in call_args.kwargs['meta']
    assert call_args.kwargs['meta']['assigned_worker_id'] == 'worker-1'
    # Verify old meta.event is NOT present
    assert 'event' not in call_args.kwargs.get('meta', {})
```

Use existing test patterns from the file for create_test_dispatcher and mocking.
</action>
  <verify>python3 -c "
import sys
sys.path.insert(0, 'tests')
from test_master_dispatcher import test_dispatch_one_broadcasts_assigned

# Run the test
try:
    test_dispatch_one_broadcasts_assigned()
    print('test_dispatch_one_broadcasts_assigned: PASSED')
except Exception as e:
    print(f'test_dispatch_one_broadcasts_assigned: FAILED - {e}')
    sys.exit(1)
"</verify>
  <done>Test verifies ASSIGNED state broadcast from dispatch_one()</done>
</task>

</tasks>

<verification>
Verify the state chain in status.log after fix:

1. Check dispatch_one() broadcasts ASSIGNED:
```bash
grep -n "BroadcastState.ASSIGNED" swarm/master_dispatcher.py
```

2. Check STATE_PRIORITY includes ASSIGNED:
```bash
grep -A8 "STATE_PRIORITY" swarm/master.py
```

3. Run the new test:
```bash
python3 -m pytest tests/test_master_dispatcher.py::test_dispatch_one_broadcasts_assigned -v
```

4. Verify status.log shows proper state chain:
```bash
# After running swarm, status.log should show:
# {"state": "ASSIGNED", ...}  <- from Master
# {"state": "START", ...}      <- from Worker
# {"state": "DONE", ...}      <- from Worker
```
</verification>

<success_criteria>
- [ ] dispatch_one() uses BroadcastState.ASSIGNED (not START)
- [ ] ASSIGNED has priority 4 in STATE_PRIORITY (between START and DONE)
- [ ] Status summary shows ASSIGNED tasks
- [ ] Status.log shows pure ASSIGNED state (no meta.event='ASSIGNED')
- [ ] State chain: ASSIGNED → START → DONE/ERROR
- [ ] Test passes verifying ASSIGNED broadcast
</success_criteria>

<output>
After completion, create `.planning/phases/29-task-assignment闭环/29-01-SUMMARY.md`
