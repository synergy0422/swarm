---
phase: 20-selfcheck-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/swarm_selfcheck.sh
autonomous: true

must_haves:
  truths:
    - "User can run ./scripts/swarm_selfcheck.sh to verify system health"
    - "Self-check reports tmux availability (installed/version)"
    - "Self-check validates all core scripts are executable"
    - "Self-check verifies configuration files exist and are readable"
    - "Self-check provides clear pass/fail output with fix suggestions"
    - "Exit code 0 if all checks pass, non-zero if any failures"
  artifacts:
    - path: "scripts/swarm_selfcheck.sh"
      provides: "System health validation for tmux, scripts, and config"
      min_lines: 150
      executable: true
  key_links:
    - from: "scripts/swarm_selfcheck.sh"
      to: "scripts/_common.sh"
      via: "source _common.sh for SWARM_STATE_DIR configuration"
      pattern: "source.*_common\\.sh"
    - from: "scripts/swarm_selfcheck.sh"
      to: "tmux"
      via: "command -v to detect tmux availability"
      pattern: "command -v tmux"
---

<objective>
Create a self-check script that validates tmux availability, script executability, and configuration readability. This provides a single command to verify system health before running swarm operations.

Purpose: Enable users to quickly diagnose environment issues without manual debugging
Output: Executable scripts/swarm_selfcheck.sh with clear pass/fail reporting
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-unified-config/18-01-SUMMARY.md
@.planning/phases/15-common-sh/15-01-SUMMARY.md

# Reference implementation patterns
@scripts/_common.sh
@scripts/_config.sh
@scripts/swarm_lock.sh (usage/help pattern)
</context>

<tasks>

<task type="auto">
  <name>Create swarm_selfcheck.sh with core script structure</name>
  <files>scripts/swarm_selfcheck.sh</files>
  <action>
Create scripts/swarm_selfcheck.sh with:

1. **Shebang and error handling**:
   - `#!/bin/bash` with `set -euo pipefail`

2. **Define SCRIPT_DIR locally** (NOT from _common.sh - it's unset there):
   ```bash
   # Determine script directory (handles symlinks and bash -c)
   SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
   ```

3. **Source _common.sh** for SWARM_STATE_DIR configuration only:
   - Use the same pattern as swarm_lock.sh and swarm_status_log.sh
   - NOTE: _common.sh does NOT export SCRIPT_DIR (it's unset after sourcing _config.sh)

4. **Output control functions** (respect QUIET_MODE and VERBOSE_MODE):
   ```bash
   # Print pass message (suppressed in quiet mode)
   print_pass() {
       [[ "${QUIET_MODE:-0}" == "1" ]] && return 0
       echo "[PASS] $*" >&2
   }

   # Print fail message (always shown, even in quiet mode)
   print_fail() {
       echo "[FAIL] $*" >&2
   }

   # Print info message (only in verbose mode)
   print_info() {
       [[ "${VERBOSE_MODE:-0}" == "1" ]] && echo "[INFO] $*" >&2
   }
   ```

5. **Usage function** with clear examples:
   ```bash
   usage() {
       cat <<EOF
   Usage: $(basename "$0") [options]

   Run system health checks for AI Swarm environment.

   Options:
       -v, --verbose    Show detailed check output
       -q, --quiet      Only report failures
       -h, --help       Show this help message

   Checks performed:
       1. tmux availability and version
       2. Core scripts executability
       3. Configuration files readability
       4. State directory accessibility

   Exit codes:
       0 - All checks passed
       1 - One or more checks failed

   Examples:
       $(basename "$0")              # Run all checks
       $(basename "$0") -v           # Verbose output
       $(basename "$0") -q           # Quiet mode (failures only)
   EOF
   }
   ```

6. **Parse command-line arguments**:
   - Support `-v|--verbose`, `-q|--quiet`, `-h|--help`
   - Set VERBOSE_MODE=1 or QUIET_MODE=1 accordingly

7. **Define script lists**:
   - CORE_SCRIPTS array: All .sh scripts in scripts/ directory
   - CONFIG_FILES array: scripts/_config.sh, scripts/_common.sh

Do NOT add actual check functions yet - Task 2 will add those.
  </action>
  <verify>
  - `./scripts/swarm_selfcheck.sh --help` displays usage
  - Script is executable: `ls -l scripts/swarm_selfcheck.sh` shows -rwxr-xr-x
  - Script defines SCRIPT_DIR locally: `grep -q 'SCRIPT_DIR=' scripts/swarm_selfcheck.sh`
  - Script has print_pass/print_fail/print_info: `grep -q "print_pass()" scripts/swarm_selfcheck.sh`
  </verify>
  <done>
  Script structure created with shebang, local SCRIPT_DIR, output control functions, usage, and argument parsing
  </done>
</task>

<task type="auto">
  <name>Implement check functions for tmux, scripts, and config</name>
  <files>scripts/swarm_selfcheck.sh</files>
  <action>
Add check functions to scripts/swarm_selfcheck.sh:

1. **check_tmux()** - Validate tmux availability:
   - Use `command -v tmux` to detect if tmux is installed
   - If found, capture version with `tmux -V`
   - Use `print_pass "tmux is installed (version X.Y)"` or `print_fail "tmux not found"`
   - Suggest fix with `print_info "Install tmux: apt install tmux | brew install tmux"`
   - Set global FAILED=1 if check fails

2. **check_scripts()** - Validate script executability:
   - Iterate through CORE_SCRIPTS array (all .sh files in scripts/)
   - Skip swarm_selfcheck.sh itself
   - Check each file: `[[ -x "$script" ]]`
   - Use `print_pass "All scripts are executable"` or list failed scripts with `print_fail`
   - Suggest fix: `print_info "Run: chmod +x scripts/<script_name>"`
   - Set FAILED=1 if any scripts not executable

3. **check_config()** - Validate configuration files:
   - Check scripts/_config.sh exists and is readable: `[[ -r "$SCRIPT_DIR/_config.sh" ]]`
     * NOTE: SCRIPT_DIR is defined locally in this script, NOT from _common.sh
   - Check scripts/_common.sh exists and is readable
   - Verify SWARM_STATE_DIR is set (from _common.sh): `[[ -n "$SWARM_STATE_DIR" ]]`
   - Verify SWARM_STATE_DIR exists and is writable: `[[ -d "$SWARM_STATE_DIR" && -w "$SWARM_STATE_DIR" ]]`
   - Use `print_pass "Configuration files accessible"` or specific failures with `print_fail`
   - Suggest fixes for each failure type with `print_info`
   - Set FAILED=1 if any checks fail

4. **check_state_dir()** - Validate state directory structure:
   - Check $SWARM_STATE_DIR/locks can be created (mkdir -p test)
   - Check $SWARM_STATE_DIR/status.log can be written to (touch test)
   - Clean up test files after check
   - Use `print_pass "State directory is writable"` or specific permission issues with `print_fail`
   - Set FAILED=1 if checks fail

Output control behavior:
- **QUIET_MODE=1**: print_pass() returns silently, print_fail() and print_info() always show
- **VERBOSE_MODE=1**: print_info() shows additional diagnostic information
- **Normal mode**: print_pass() and print_fail() show, print_info() suppressed
- All output goes to stderr (>&2) to avoid interfering with data streams
  </action>
  <verify>
  - `grep -q "check_tmux()" scripts/swarm_selfcheck.sh`
  - `grep -q "check_scripts()" scripts/swarm_selfcheck.sh`
  - `grep -q "check_config()" scripts/swarm_selfcheck.sh`
  - `grep -q "check_state_dir()" scripts/swarm_selfcheck.sh`
  - `grep -q "FAILED=1" scripts/swarm_selfcheck.sh`
  - `grep -q "print_pass" scripts/swarm_selfcheck.sh`
  - `grep -q "print_fail" scripts/swarm_selfcheck.sh`
  - `grep -q "print_info" scripts/swarm_selfcheck.sh`
  </verify>
  <done>
  All four check functions implemented with print_pass/print_fail/print_info, respecting QUIET/VERBOSE modes
  </done>
</task>

<task type="auto">
  <name>Implement main check runner and exit code handling</name>
  <files>scripts/swarm_selfcheck.sh</files>
  <action>
Add main execution logic to scripts/swarm_selfcheck.sh:

1. **main() function** that orchestrates all checks:
   - Initialize FAILED=0
   - Print header: "AI Swarm System Health Check"
   - Call each check function in sequence:
     * check_tmux
     * check_scripts
     * check_config
     * check_state_dir
   - Print summary line: "=== Summary ==="
   - If FAILED=0: print "All checks passed [OK]" and exit 0
   - If FAILED=1: print "One or more checks failed [FAIL]" and exit 1

2. **Exit code handling**:
   - Ensure script exits with non-zero code if any check fails
   - This enables CI/CD pipelines to fail on health check failures

3. **Main execution guard**:
   - At bottom of script: `main "$@"` to run with all arguments
   - Ensures argument parsing happens before main()

4. **Output formatting**:
   - Use separators between check sections for readability
   - Align check output with consistent indentation
   - In verbose mode, show which checks are being run
   - In quiet mode, suppress the header and summary, only show failures

Example output structure:
```
AI Swarm System Health Check
=============================

[1/4] Checking tmux availability...
[PASS] tmux is installed (tmux 3.3a)

[2/4] Checking script executability...
[PASS] All 10 scripts are executable

[3/4] Checking configuration files...
[PASS] Configuration files accessible

[4/4] Checking state directory...
[PASS] State directory is writable

=== Summary ===
All checks passed [OK]
```
  </action>
  <verify>
  - `grep -q "main()" scripts/swarm_selfcheck.sh`
  - `grep -q "exit 0" scripts/swarm_selfcheck.sh`
  - `grep -q "exit 1" scripts/swarm_selfcheck.sh`
  - Run `./scripts/swarm_selfcheck.sh` and verify exit code 0 when all checks pass
  - Run `./scripts/swarm_selfcheck.sh -v` and verify verbose output
  - Run `./scripts/swarm_selfcheck.sh -q` and verify quiet mode
  - Run `./scripts/swarm_selfcheck.sh --help` and verify usage displays
  </verify>
  <done>
  Main runner executes all checks, provides clear summary, and returns correct exit codes
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. **Manual testing**:
   - `./scripts/swarm_selfcheck.sh` passes all checks on a healthy system
   - `./scripts/swarm_selfcheck.sh -v` shows detailed verbose output
   - `./scripts/swarm_selfcheck.sh -q` only shows failures (suppress [PASS] messages)
   - `./scripts/swarm_selfcheck.sh --help` displays usage information

2. **Failure scenarios** (simulate failures and verify detection):
   - Temporarily remove execute bit from a script: `chmod -x scripts/swarm_lock.sh`
     * Check should fail and suggest `chmod +x scripts/swarm_lock.sh`
   - Temporarily hide _config.sh: `mv scripts/_config.sh scripts/_config.sh.bak`
     * Check should fail and suggest restoring the file
   - Set SWARM_STATE_DIR to a non-writable directory
     * Check should fail and suggest fixing permissions

3. **Exit code validation**:
   - Success case: `./scripts/swarm_selfcheck.sh; echo $?` should output `0`
   - Failure case: Simulate a failure, verify exit code is `1`

4. **Output clarity**:
   - Pass/fail status is clearly indicated with [PASS]/[FAIL] prefixes
   - Fix suggestions are actionable and specific
   - Verbose mode provides additional detail without overwhelming output
   - Quiet mode suppresses all but failures
</verification>

<success_criteria>
Phase 20 success is achieved when:

1. **Script exists and is executable**:
   - `scripts/swarm_selfcheck.sh` exists with -rwxr-xr-x permissions

2. **All checks functional**:
   - tmux availability check detects installed/missing tmux
   - Script executability check validates all .sh files have execute bit
   - Configuration check validates _config.sh and _common.sh are readable
   - State directory check validates SWARM_STATE_DIR is writable

3. **Clear output**:
   - Pass/fail status indicated with [PASS]/[FAIL] prefixes
   - Actionable fix suggestions for each failure type
   - Summary line shows overall result (OK or FAIL)

4. **Exit codes correct**:
   - Exit 0 when all checks pass
   - Exit 1 when any check fails

5. **Command-line options work**:
   - `--help` shows usage
   - `-v|--verbose` enables detailed output
   - `-q|--quiet` suppresses pass messages
</success_criteria>

<output>
After completion, create `.planning/phases/20-selfcheck-docs/20-01-SUMMARY.md` with:

- Tasks completed
- Files modified
- What was created (script structure and features)
- Key design decisions
- Verification results (all test scenarios passed)
- Deviations from plan (if any)
- Commits made
- Duration

Follow the format from 15-01-SUMMARY.md and 18-01-SUMMARY.md.
</output>
